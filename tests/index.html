<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit Tests - Azure Local Wizard</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background: #0a0e27;
            color: #e0e7ff;
        }
        h1 { color: #60a5fa; }
        .test-suite {
            background: #1a1f3a;
            border: 1px solid #2d3653;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .test-suite h2 {
            color: #60a5fa;
            margin-top: 0;
            font-size: 1.1rem;
        }
        .test-case {
            padding: 8px 12px;
            margin: 6px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }
        .test-case.pass {
            background: rgba(16, 185, 129, 0.1);
            border-left: 4px solid #10b981;
        }
        .test-case.fail {
            background: rgba(239, 68, 68, 0.1);
            border-left: 4px solid #ef4444;
        }
        .test-status {
            font-weight: bold;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
        }
        .test-status.pass { color: #10b981; }
        .test-status.fail { color: #ef4444; }
        .summary {
            background: linear-gradient(135deg, #1a1f3a, #2d3653);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 24px;
            text-align: center;
            border: 1px solid #3d4663;
        }
        .summary-stat {
            display: inline-block;
            margin: 0 24px;
            font-size: 16px;
        }
        .summary-stat .number {
            font-size: 36px;
            font-weight: bold;
            display: block;
        }
        .summary-stat.pass .number { color: #10b981; }
        .summary-stat.fail .number { color: #ef4444; }
        .module-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            margin-left: 8px;
            background: rgba(96, 165, 250, 0.2);
            color: #60a5fa;
        }
        .section-header {
            background: #2d3653;
            padding: 12px 16px;
            border-radius: 8px;
            margin: 24px 0 16px 0;
            font-size: 1.2rem;
            font-weight: 600;
            color: #a5b4fc;
        }
    </style>
</head>
<body>
    <h1>üß™ Unit Tests - Azure Local Wizard</h1>
    <p>Comprehensive test suite for ODIN modular JavaScript functions</p>
    
    <div id="summary" class="summary">
        <div class="summary-stat pass">
            <span class="number" id="pass-count">0</span>
            <span>Passed</span>
        </div>
        <div class="summary-stat fail">
            <span class="number" id="fail-count">0</span>
            <span>Failed</span>
        </div>
        <div class="summary-stat">
            <span class="number" id="total-count">0</span>
            <span>Total</span>
        </div>
    </div>
    
    <div id="test-results"></div>
    
    <!-- Modular JavaScript files (load before main script.js) -->
    <script src="../js/utils.js"></script>
    <script src="../js/notifications.js"></script>
    <script src="../js/analytics.js"></script>
    <script src="../js/theme.js"></script>
    <script src="../js/formatting.js"></script>
    <script src="../js/validation.js"></script>
    <script src="../js/dns.js"></script>
    <script src="../js/script.js"></script>
    <script>
        // ========================================================================
        // TEST FRAMEWORK
        // ========================================================================
        // Override alert() to prevent headless Chrome hangs during ARM generation tests
        window.alert = function() {};

        let passCount = 0;
        let failCount = 0;
        let totalCount = 0;
        
        // Structured test results for CI/CD extraction (JUnit XML generation)
        window.testResults = [];
        let currentSuite = null;
        let currentSection = null;
        
        function assert(condition, testName, expected, actual) {
            totalCount++;
            const testCase = document.createElement('div');
            testCase.className = 'test-case';
            
            // Store structured result for CI extraction
            const result = {
                name: testName,
                suite: currentSuite || 'Default',
                section: currentSection || 'Tests',
                passed: condition,
                expected: String(expected),
                actual: String(actual),
                timestamp: new Date().toISOString()
            };
            window.testResults.push(result);
            
            if (condition) {
                passCount++;
                testCase.classList.add('pass');
                testCase.innerHTML = `
                    <span>${testName}</span>
                    <span class="test-status pass">‚úì PASS</span>
                `;
            } else {
                failCount++;
                testCase.classList.add('fail');
                testCase.innerHTML = `
                    <span>${testName}<br><small style="color:#f87171;">Expected: ${expected}, Got: ${actual}</small></span>
                    <span class="test-status fail">‚úó FAIL</span>
                `;
            }
            
            return testCase;
        }
        
        function testSuite(name, moduleName, tests) {
            currentSuite = `${name} (${moduleName})`;
            const suite = document.createElement('div');
            suite.className = 'test-suite';
            suite.innerHTML = `<h2>${name} <span class="module-badge">${moduleName}</span></h2>`;
            
            tests.forEach(test => {
                if (test) suite.appendChild(test);
            });
            
            document.getElementById('test-results').appendChild(suite);
        }
        
        function sectionHeader(title) {
            currentSection = title.replace(/[^\w\s]/g, '').trim();
            const header = document.createElement('div');
            header.className = 'section-header';
            header.textContent = title;
            document.getElementById('test-results').appendChild(header);
        }
        
        function updateTestSummary() {
            document.getElementById('pass-count').textContent = passCount;
            document.getElementById('fail-count').textContent = failCount;
            document.getElementById('total-count').textContent = totalCount;
        }

        // ========================================================================
        // JS/UTILS.JS TESTS
        // ========================================================================
        sectionHeader('üì¶ js/utils.js - Core Utilities');
        
        // Test: isValidNetbiosName
        testSuite('isValidNetbiosName()', 'utils.js', [
            assert(isValidNetbiosName('SERVER01') === true, 'Valid: SERVER01', true, isValidNetbiosName('SERVER01')),
            assert(isValidNetbiosName('Node-1') === true, 'Valid: Node-1 (with hyphen)', true, isValidNetbiosName('Node-1')),
            assert(isValidNetbiosName('A') === true, 'Valid: Single character', true, isValidNetbiosName('A')),
            assert(isValidNetbiosName('AAAAAAAAAAAAAAA') === true, 'Valid: 15 characters (max)', true, isValidNetbiosName('AAAAAAAAAAAAAAA')),
            assert(isValidNetbiosName('A-B') === true, 'Valid: 3 chars with hyphen', true, isValidNetbiosName('A-B')),
            assert(isValidNetbiosName('-SERVER') === false, 'Invalid: Starts with hyphen', false, isValidNetbiosName('-SERVER')),
            assert(isValidNetbiosName('SERVER-') === false, 'Invalid: Ends with hyphen', false, isValidNetbiosName('SERVER-')),
            assert(isValidNetbiosName('AAAAAAAAAAAAAAAA') === false, 'Invalid: 16 characters (too long)', false, isValidNetbiosName('AAAAAAAAAAAAAAAA')),
            assert(isValidNetbiosName('') === false, 'Invalid: Empty string', false, isValidNetbiosName('')),
            assert(isValidNetbiosName('Server 01') === false, 'Invalid: Contains space', false, isValidNetbiosName('Server 01')),
            assert(isValidNetbiosName('Server_01') === false, 'Invalid: Contains underscore', false, isValidNetbiosName('Server_01')),
            assert(isValidNetbiosName(null) === false, 'Invalid: null', false, isValidNetbiosName(null)),
            assert(isValidNetbiosName(undefined) === false, 'Invalid: undefined', false, isValidNetbiosName(undefined))
        ]);
        
        // Test: isValidIpv4Cidr
        testSuite('isValidIpv4Cidr()', 'utils.js', [
            assert(isValidIpv4Cidr('192.168.1.0/24') === true, 'Valid: 192.168.1.0/24', true, isValidIpv4Cidr('192.168.1.0/24')),
            assert(isValidIpv4Cidr('10.0.0.0/8') === true, 'Valid: 10.0.0.0/8', true, isValidIpv4Cidr('10.0.0.0/8')),
            assert(isValidIpv4Cidr('172.16.0.0/16') === true, 'Valid: 172.16.0.0/16', true, isValidIpv4Cidr('172.16.0.0/16')),
            assert(isValidIpv4Cidr('0.0.0.0/0') === true, 'Valid: 0.0.0.0/0 (any)', true, isValidIpv4Cidr('0.0.0.0/0')),
            assert(isValidIpv4Cidr('255.255.255.255/32') === true, 'Valid: 255.255.255.255/32 (host)', true, isValidIpv4Cidr('255.255.255.255/32')),
            assert(isValidIpv4Cidr('192.168.1.0') === false, 'Invalid: Missing CIDR prefix', false, isValidIpv4Cidr('192.168.1.0')),
            assert(isValidIpv4Cidr('192.168.1.0/33') === false, 'Invalid: /33 (out of range)', false, isValidIpv4Cidr('192.168.1.0/33')),
            assert(isValidIpv4Cidr('192.168.1.0/-1') === false, 'Invalid: /-1 (negative)', false, isValidIpv4Cidr('192.168.1.0/-1')),
            assert(isValidIpv4Cidr('256.168.1.0/24') === false, 'Invalid: 256 in octet', false, isValidIpv4Cidr('256.168.1.0/24')),
            assert(isValidIpv4Cidr('192.168/24') === false, 'Invalid: Missing octets', false, isValidIpv4Cidr('192.168/24')),
            assert(isValidIpv4Cidr('') === false, 'Invalid: Empty string', false, isValidIpv4Cidr('')),
            assert(isValidIpv4Cidr(null) === false, 'Invalid: null', false, isValidIpv4Cidr(null))
        ]);
        
        // Test: isValidCidrFormat
        testSuite('isValidCidrFormat()', 'utils.js', [
            assert(isValidCidrFormat('10.0.1.0/24') === true, 'Valid: 10.0.1.0/24', true, isValidCidrFormat('10.0.1.0/24')),
            assert(isValidCidrFormat('192.168.0.0/16') === true, 'Valid: 192.168.0.0/16', true, isValidCidrFormat('192.168.0.0/16')),
            assert(isValidCidrFormat('10.0.1.0') === false, 'Invalid: No prefix', false, isValidCidrFormat('10.0.1.0')),
            assert(isValidCidrFormat('10.0.1/24') === false, 'Invalid: 3 octets only', false, isValidCidrFormat('10.0.1/24')),
            assert(isValidCidrFormat('') === false, 'Invalid: Empty', false, isValidCidrFormat('')),
            assert(isValidCidrFormat(null) === false, 'Invalid: null', false, isValidCidrFormat(null))
        ]);
        
        // Test: escapeHtml
        testSuite('escapeHtml()', 'utils.js', [
            (function() {
                const input = '\x3Cscript\x3Ealert("xss")\x3C/script\x3E';
                const expected = '&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;';
                const result = escapeHtml(input);
                return assert(result === expected, 'Escapes script tags', expected, result);
            })(),
            assert(escapeHtml('Hello & Goodbye') === 'Hello &amp; Goodbye', 
                'Escapes ampersand', 'Hello &amp; Goodbye', escapeHtml('Hello & Goodbye')),
            (function() {
                const input = "'single' \"double\"";
                const expected = '&#39;single&#39; &quot;double&quot;';
                const result = escapeHtml(input);
                return assert(result === expected, 'Escapes quotes', expected, result);
            })(),
            assert(escapeHtml('Normal text') === 'Normal text', 
                'No escaping needed', 'Normal text', escapeHtml('Normal text')),
            assert(escapeHtml('') === '', 'Empty string returns empty', '', escapeHtml(''))
        ]);
        
        // Test: sanitizeInput
        testSuite('sanitizeInput()', 'utils.js', [
            (function() {
                const input = '\x3Cb\x3EBold\x3C/b\x3E';
                const expected = '&lt;b&gt;Bold&lt;/b&gt;';
                const result = sanitizeInput(input, 'html');
                return assert(result === expected, 'HTML sanitization', expected, result);
            })(),
            assert(sanitizeInput('file name.txt', 'filename') === 'file_name.txt', 
                'Filename sanitization', 'file_name.txt', sanitizeInput('file name.txt', 'filename')),
            assert(sanitizeInput('hello world', 'url').includes('hello'), 
                'URL encoding preserves text', true, sanitizeInput('hello world', 'url').includes('hello')),
            assert(sanitizeInput('hello world', 'url') === 'hello%20world', 
                'URL encodes spaces', 'hello%20world', sanitizeInput('hello world', 'url')),
            assert(sanitizeInput('  trimmed  ', 'text').trim() === 'trimmed', 
                'Trims whitespace', 'trimmed', sanitizeInput('  trimmed  ', 'text').trim()),
            assert(sanitizeInput('', 'html') === '', 'Empty returns empty', '', sanitizeInput('', 'html')),
            assert(sanitizeInput(null, 'html') === '', 'Null returns empty', '', sanitizeInput(null, 'html'))
        ]);
        
        // Test: formatNumber
        testSuite('formatNumber()', 'utils.js', [
            assert(formatNumber(1000) === '1,000', 'Formats 1000', '1,000', formatNumber(1000)),
            assert(formatNumber(1000000) === '1,000,000', 'Formats 1000000', '1,000,000', formatNumber(1000000)),
            assert(formatNumber(999) === '999', 'No comma for 999', '999', formatNumber(999)),
            assert(formatNumber(0) === '0', 'Zero returns 0', '0', formatNumber(0)),
            assert(formatNumber(12345678) === '12,345,678', 'Large number', '12,345,678', formatNumber(12345678))
        ]);
        
        // Test: capitalize
        testSuite('capitalize()', 'utils.js', [
            assert(capitalize('hello') === 'Hello', 'Capitalizes hello', 'Hello', capitalize('hello')),
            assert(capitalize('HELLO') === 'HELLO', 'Preserves uppercase', 'HELLO', capitalize('HELLO')),
            assert(capitalize('a') === 'A', 'Single char', 'A', capitalize('a')),
            assert(capitalize('') === '', 'Empty string', '', capitalize('')),
            assert(capitalize(null) === '', 'Null returns empty', '', capitalize(null))
        ]);
        
        // Test: IP Conversion Functions
        testSuite('ipToLong() / longToIp()', 'utils.js', [
            assert(longToIp(ipToLong('192.168.1.1')) === '192.168.1.1', 
                'Round-trip: 192.168.1.1', '192.168.1.1', longToIp(ipToLong('192.168.1.1'))),
            assert(longToIp(ipToLong('10.0.0.1')) === '10.0.0.1', 
                'Round-trip: 10.0.0.1', '10.0.0.1', longToIp(ipToLong('10.0.0.1'))),
            assert(longToIp(ipToLong('255.255.255.255')) === '255.255.255.255', 
                'Round-trip: 255.255.255.255', '255.255.255.255', longToIp(ipToLong('255.255.255.255'))),
            assert(longToIp(ipToLong('0.0.0.0')) === '0.0.0.0', 
                'Round-trip: 0.0.0.0', '0.0.0.0', longToIp(ipToLong('0.0.0.0'))),
            assert(ipToLong('192.168.1.1') === 3232235777, 
                'ipToLong: 192.168.1.1', 3232235777, ipToLong('192.168.1.1')),
            assert(ipToLong('10.0.0.1') === 167772161, 
                'ipToLong: 10.0.0.1', 167772161, ipToLong('10.0.0.1')),
            assert(longToIp(3232235777) === '192.168.1.1', 
                'longToIp: 3232235777', '192.168.1.1', longToIp(3232235777)),
            assert(longToIp(0) === '0.0.0.0', 
                'longToIp: 0', '0.0.0.0', longToIp(0))
        ]);
        
        // Test: ipv4ToInt / intToIpv4
        testSuite('ipv4ToInt() / intToIpv4()', 'utils.js', [
            assert(intToIpv4(ipv4ToInt('192.168.1.1')) === '192.168.1.1', 
                'Round-trip: 192.168.1.1', '192.168.1.1', intToIpv4(ipv4ToInt('192.168.1.1'))),
            assert(ipv4ToInt('0.0.0.0') === 0, 'ipv4ToInt: 0.0.0.0', 0, ipv4ToInt('0.0.0.0')),
            assert(ipv4ToInt('255.255.255.255') === 4294967295, 
                'ipv4ToInt: 255.255.255.255', 4294967295, ipv4ToInt('255.255.255.255')),
            assert(ipv4ToInt('invalid') === null, 'Invalid IP returns null', null, ipv4ToInt('invalid')),
            assert(ipv4ToInt('') === null, 'Empty returns null', null, ipv4ToInt(''))
        ]);
        
        // Test: extractIpFromCidr
        testSuite('extractIpFromCidr()', 'utils.js', [
            assert(extractIpFromCidr('192.168.1.0/24') === '192.168.1.0', 
                'Extract from 192.168.1.0/24', '192.168.1.0', extractIpFromCidr('192.168.1.0/24')),
            assert(extractIpFromCidr('10.0.0.0/8') === '10.0.0.0', 
                'Extract from 10.0.0.0/8', '10.0.0.0', extractIpFromCidr('10.0.0.0/8')),
            assert(extractIpFromCidr('') === '', 'Empty returns empty', '', extractIpFromCidr('')),
            assert(extractIpFromCidr(null) === '', 'Null returns empty', '', extractIpFromCidr(null))
        ]);
        
        // Test: extractPrefixFromCidr
        testSuite('extractPrefixFromCidr()', 'utils.js', [
            assert(extractPrefixFromCidr('192.168.1.0/24') === 24, 
                'Extract /24', 24, extractPrefixFromCidr('192.168.1.0/24')),
            assert(extractPrefixFromCidr('10.0.0.0/8') === 8, 
                'Extract /8', 8, extractPrefixFromCidr('10.0.0.0/8')),
            assert(extractPrefixFromCidr('0.0.0.0/0') === 0, 
                'Extract /0', 0, extractPrefixFromCidr('0.0.0.0/0')),
            assert(extractPrefixFromCidr('192.168.1.0') === null, 
                'No prefix returns null', null, extractPrefixFromCidr('192.168.1.0')),
            assert(extractPrefixFromCidr('') === null, 'Empty returns null', null, extractPrefixFromCidr(''))
        ]);
        
        // Test: prefixToMask
        testSuite('prefixToMask()', 'utils.js', [
            assert(prefixToMask(24) === 4294967040, '/24 mask', 4294967040, prefixToMask(24)),
            assert(prefixToMask(32) === 4294967295, '/32 mask (all ones)', 4294967295, prefixToMask(32)),
            assert(prefixToMask(0) === 0, '/0 mask (all zeros)', 0, prefixToMask(0)),
            assert(prefixToMask(16) === 4294901760, '/16 mask', 4294901760, prefixToMask(16)),
            assert(prefixToMask(33) === null, '/33 invalid', null, prefixToMask(33)),
            assert(prefixToMask(-1) === null, '/-1 invalid', null, prefixToMask(-1))
        ]);
        
        // Test: incrementCidrThirdOctet
        testSuite('incrementCidrThirdOctet()', 'utils.js', [
            assert(incrementCidrThirdOctet('10.0.1.0/24', 1) === '10.0.2.0/24', 
                'Increment 10.0.1.0/24 by 1', '10.0.2.0/24', incrementCidrThirdOctet('10.0.1.0/24', 1)),
            assert(incrementCidrThirdOctet('10.0.1.0/24', 10) === '10.0.11.0/24', 
                'Increment by 10', '10.0.11.0/24', incrementCidrThirdOctet('10.0.1.0/24', 10)),
            assert(incrementCidrThirdOctet('10.0.254.0/24', 1) === '10.0.255.0/24', 
                'Increment to 255', '10.0.255.0/24', incrementCidrThirdOctet('10.0.254.0/24', 1)),
            assert(incrementCidrThirdOctet('10.0.255.0/24', 1) === null, 
                'Overflow returns null', null, incrementCidrThirdOctet('10.0.255.0/24', 1)),
            assert(incrementCidrThirdOctet('invalid', 1) === null, 
                'Invalid CIDR returns null', null, incrementCidrThirdOctet('invalid', 1))
        ]);

        // ========================================================================
        // JS/FORMATTING.JS TESTS
        // ========================================================================
        sectionHeader('üé® js/formatting.js - Display Formatting');
        
        // Test: formatScenario
        testSuite('formatScenario()', 'formatting.js', [
            assert(formatScenario('hyperconverged') === 'Hyperconverged', 
                'Hyperconverged', 'Hyperconverged', formatScenario('hyperconverged')),
            assert(formatScenario('multirack') === 'Multi-Rack', 
                'Multi-Rack', 'Multi-Rack', formatScenario('multirack')),
            assert(formatScenario('disconnected') === 'Disconnected (Air Gapped)', 
                'Disconnected', 'Disconnected (Air Gapped)', formatScenario('disconnected')),
            assert(formatScenario('m365local') === 'M365 Local', 
                'M365 Local', 'M365 Local', formatScenario('m365local')),
            assert(formatScenario('') === '', 'Empty returns empty', '', formatScenario('')),
            assert(formatScenario('custom') === 'Custom', 'Unknown capitalizes', 'Custom', formatScenario('custom'))
        ]);
        
        // Test: formatScale
        testSuite('formatScale()', 'formatting.js', [
            assert(formatScale('low_capacity') === 'Low Capacity', 
                'Low Capacity', 'Low Capacity', formatScale('low_capacity')),
            assert(formatScale('medium') === 'Hyperconverged (1-16 Nodes)', 
                'Medium', 'Hyperconverged (1-16 Nodes)', formatScale('medium')),
            assert(formatScale('rack_aware') === 'Rack Aware (Multi-Room)', 
                'Rack Aware', 'Rack Aware (Multi-Room)', formatScale('rack_aware')),
            assert(formatScale('rack_scale') === 'Rack Scale', 
                'Rack Scale', 'Rack Scale', formatScale('rack_scale'))
        ]);
        
        // Test: formatOutbound
        testSuite('formatOutbound()', 'formatting.js', [
            assert(formatOutbound('public') === 'Public Internet', 
                'Public', 'Public Internet', formatOutbound('public')),
            assert(formatOutbound('private') === 'ExpressRoute / VPN', 
                'Private', 'ExpressRoute / VPN', formatOutbound('private')),
            assert(formatOutbound('air_gapped') === 'Air Gapped', 
                'Air Gapped', 'Air Gapped', formatOutbound('air_gapped')),
            assert(formatOutbound('limited') === 'Limited Connectivity', 
                'Limited', 'Limited Connectivity', formatOutbound('limited'))
        ]);

        // Test: getProxyLabel
        testSuite('getProxyLabel()', 'formatting.js', [
            (function() {
                const origProxy = state.proxy;
                state.proxy = null;
                const result = getProxyLabel();
                state.proxy = origProxy;
                return assert(result === '-', 'No proxy returns dash', '-', result);
            })(),
            (function() {
                const origProxy = state.proxy;
                state.proxy = 'no_proxy';
                const result = getProxyLabel();
                state.proxy = origProxy;
                return assert(result === 'Disabled', 'no_proxy returns Disabled', 'Disabled', result);
            })()
        ]);

        // ========================================================================
        // JS/VALIDATION.JS TESTS
        // ========================================================================
        sectionHeader('‚úÖ js/validation.js - Input Validation');
        
        // Test: validateFieldRealtime (we need to create mock elements)
        testSuite('validateFieldRealtime() - Logic Only', 'validation.js', [
            (function() {
                // Create mock input and feedback element
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                mockInput.parentNode || document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, 'SERVER01', 'netbios');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === true, 'Valid NetBIOS name', true, result);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, '-INVALID', 'netbios');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === false, 'Invalid NetBIOS name', false, result);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, '192.168.1.10/24', 'ipv4cidr');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === true, 'Valid IPv4 CIDR', true, result);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, '192.168.1.1', 'ipv4');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === true, 'Valid IPv4 address', true, result);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, 'contoso.com', 'domain');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === true, 'Valid domain', true, result);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, '100', 'vlan');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === true, 'Valid VLAN (100)', true, result);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, '5000', 'vlan');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === false, 'Invalid VLAN (5000 > 4094)', false, result);
            })()
        ]);

        // ========================================================================
        // JS/DNS.JS TESTS
        // ========================================================================
        sectionHeader('üåê js/dns.js - DNS Server Management');
        
        // Test: DNS Server Array Management
        testSuite('DNS Server Array Management', 'dns.js', [
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['192.168.1.1'];
                addDnsServer();
                const result = state.dnsServers.length === 2;
                state.dnsServers = origServers;
                return assert(result, 'addDnsServer() adds empty entry', 2, state.dnsServers.length);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['192.168.1.1', '192.168.1.2', '192.168.1.3'];
                removeDnsServer(1);
                const result = state.dnsServers.length === 2 && state.dnsServers[1] === '192.168.1.3';
                state.dnsServers = origServers;
                return assert(result, 'removeDnsServer(1) removes middle entry', true, result);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['192.168.1.1'];
                updateDnsServer(0, '  10.0.0.1  ');
                const result = state.dnsServers[0] === '10.0.0.1';
                state.dnsServers = origServers;
                return assert(result, 'updateDnsServer() trims whitespace', '10.0.0.1', state.dnsServers[0]);
            })()
        ]);

        // Test: DNS Validation - Format
        testSuite('DNS Validation - IP Format', 'dns.js', [
            (function() {
                // Test valid IPs don't trigger error
                const origServers = [...state.dnsServers];
                state.dnsServers = ['192.168.1.1', '10.0.0.1'];
                
                // Create mock error/success elements
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = errDiv.classList.contains('hidden');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                return assert(result, 'Valid IPs pass validation', true, result);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['invalid-ip'];
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = !errDiv.classList.contains('hidden');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                return assert(result, 'Invalid IP shows error', true, result);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['256.1.1.1']; // Invalid octet
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = !errDiv.classList.contains('hidden');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                return assert(result, 'IP with invalid octet (256) fails', true, result);
            })()
        ]);

        // Test: DNS Validation - AKS Reserved Subnets
        testSuite('DNS Validation - AKS Reserved Subnets', 'dns.js', [
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['10.96.0.1']; // Within 10.96.0.0/12
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = errDiv.innerText.includes('AKS subnet');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                return assert(result, 'DNS in 10.96.0.0/12 shows AKS error', true, result);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['10.244.1.1']; // Within 10.244.0.0/16
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = errDiv.innerText.includes('AKS subnet');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                return assert(result, 'DNS in 10.244.0.0/16 shows AKS error', true, result);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['10.95.254.1']; // Just outside 10.96.0.0/12
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = errDiv.classList.contains('hidden');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                return assert(result, 'DNS outside AKS range passes', true, result);
            })()
        ]);

        // Test: DNS Validation - Infrastructure Network Overlap
        testSuite('DNS Validation - Infrastructure Network', 'dns.js', [
            (function() {
                const origServers = [...state.dnsServers];
                const origInfra = state.infra ? { ...state.infra } : null;
                
                state.dnsServers = ['192.168.1.100'];
                state.infra = { start: '192.168.1.1', end: '192.168.1.200' };
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = errDiv.innerText.includes('Infrastructure Network');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                state.infra = origInfra;
                return assert(result, 'DNS in infra range shows error', true, result);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                const origInfra = state.infra ? { ...state.infra } : null;
                
                state.dnsServers = ['192.168.2.1'];
                state.infra = { start: '192.168.1.1', end: '192.168.1.200' };
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = errDiv.classList.contains('hidden');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                state.infra = origInfra;
                return assert(result, 'DNS outside infra range passes', true, result);
            })()
        ]);

        // Test: DNS Service Existing State
        testSuite('DNS Service Existing State', 'dns.js', [
            (function() {
                const origValue = state.dnsServiceExisting;
                updateDnsServiceExisting('yes');
                const result = state.dnsServiceExisting === true;
                state.dnsServiceExisting = origValue;
                return assert(result, 'updateDnsServiceExisting("yes") sets true', true, result);
            })(),
            (function() {
                const origValue = state.dnsServiceExisting;
                updateDnsServiceExisting('no');
                const result = state.dnsServiceExisting === false;
                state.dnsServiceExisting = origValue;
                return assert(result, 'updateDnsServiceExisting("no") sets false', false, result);
            })()
        ]);

        // Test: Local DNS Zone
        testSuite('Local DNS Zone', 'dns.js', [
            (function() {
                // Create mock input element
                const mockInput = document.createElement('input');
                mockInput.id = 'local-dns-zone-input';
                mockInput.value = '  azurelocal.local  ';
                document.body.appendChild(mockInput);
                
                const origValue = state.localDnsZone;
                updateLocalDnsZone();
                const result = state.localDnsZone === 'azurelocal.local';
                
                mockInput.remove();
                state.localDnsZone = origValue;
                return assert(result, 'updateLocalDnsZone() trims value', 'azurelocal.local', state.localDnsZone);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                mockInput.id = 'local-dns-zone-input';
                mockInput.value = '';
                document.body.appendChild(mockInput);
                
                const origValue = state.localDnsZone;
                updateLocalDnsZone();
                const result = state.localDnsZone === null;
                
                mockInput.remove();
                state.localDnsZone = origValue;
                return assert(result, 'Empty input sets null', null, state.localDnsZone);
            })()
        ]);

        // ========================================================================
        // JS/THEME.JS TESTS
        // ========================================================================
        sectionHeader('üé® js/theme.js - Theme Functions');
        
        testSuite('Theme Functions', 'theme.js', [
            (function() {
                const origFontSize = state.fontSize;
                state.fontSize = 'medium';
                increaseFontSize();
                const result = state.fontSize === 'large';
                state.fontSize = origFontSize;
                return assert(result, 'increaseFontSize() medium ‚Üí large', 'large', state.fontSize);
            })(),
            (function() {
                const origFontSize = state.fontSize;
                state.fontSize = 'medium';
                decreaseFontSize();
                const result = state.fontSize === 'small';
                state.fontSize = origFontSize;
                return assert(result, 'decreaseFontSize() medium ‚Üí small', 'small', state.fontSize);
            })(),
            (function() {
                const origFontSize = state.fontSize;
                state.fontSize = 'small'; // minimum
                decreaseFontSize();
                const result = state.fontSize === 'small'; // should not go below small
                state.fontSize = origFontSize;
                return assert(result, 'Font size minimum is small', 'small', state.fontSize);
            })(),
            (function() {
                const origFontSize = state.fontSize;
                state.fontSize = 'x-large'; // maximum
                increaseFontSize();
                const result = state.fontSize === 'x-large'; // should not exceed x-large
                state.fontSize = origFontSize;
                return assert(result, 'Font size maximum is x-large', 'x-large', state.fontSize);
            })()
        ]);

        // ========================================================================
        // EDGE CASES & BOUNDARY TESTS
        // ========================================================================
        sectionHeader('üî¨ Edge Cases & Boundary Tests');
        
        testSuite('Null/Undefined Handling', 'utils.js', [
            assert(escapeHtml(null) === 'null', 'escapeHtml(null)', 'null', escapeHtml(null)),
            assert(escapeHtml(undefined) === 'undefined', 'escapeHtml(undefined)', 'undefined', escapeHtml(undefined)),
            assert(formatNumber(0) === '0', 'formatNumber(0)', '0', formatNumber(0)),
            assert(isValidNetbiosName(0) === false, 'isValidNetbiosName(0)', false, isValidNetbiosName(0))
        ]);
        
        testSuite('IP Address Edge Cases', 'utils.js', [
            assert(ipToLong('0.0.0.1') === 1, 'Min non-zero IP', 1, ipToLong('0.0.0.1')),
            assert(ipToLong('255.255.255.254') === 4294967294, 'Max-1 IP', 4294967294, ipToLong('255.255.255.254')),
            assert(isValidIpv4Cidr('192.168.1.0/0') === true, '/0 is valid', true, isValidIpv4Cidr('192.168.1.0/0')),
            assert(isValidIpv4Cidr('192.168.1.0/32') === true, '/32 is valid', true, isValidIpv4Cidr('192.168.1.0/32'))
        ]);

        // ========================================================================
        // HTML PAGE VALIDATION TESTS
        // ========================================================================
        sectionHeader('üìÑ HTML Page Validation');

        // Note: These tests require HTTP server (e.g., serve.ps1) to work.
        // They will be skipped when running via file:// protocol (e.g., in CI pipeline).
        // The CI pipeline uses html-validate for HTML syntax checking instead.

        // Helper function to fetch and validate HTML pages
        async function validateHtmlPage(pagePath, pageName, requiredElements) {
            try {
                const response = await fetch(pagePath);
                if (!response.ok) {
                    return { success: false, error: `Failed to fetch ${pageName}: ${response.status}` };
                }
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Check for parse errors (malformed HTML)
                const parseError = doc.querySelector('parsererror');
                if (parseError) {
                    return { success: false, error: 'HTML parse error detected' };
                }
                
                // Check for unclosed style tags (common error)
                const styleTagCount = (html.match(/<style/gi) || []).length;
                const styleCloseCount = (html.match(/<\/style>/gi) || []).length;
                if (styleTagCount !== styleCloseCount) {
                    return { success: false, error: `Mismatched style tags: ${styleTagCount} open, ${styleCloseCount} close` };
                }
                
                // Check required elements
                const missing = [];
                for (const selector of requiredElements) {
                    if (!doc.querySelector(selector)) {
                        missing.push(selector);
                    }
                }
                
                if (missing.length > 0) {
                    return { success: false, error: `Missing elements: ${missing.join(', ')}` };
                }
                
                return { success: true, doc: doc };
            } catch (err) {
                return { success: false, error: err.message };
            }
        }

        // Run async HTML validation tests (only when served via HTTP)
        (async function runHtmlValidationTests() {
            // Skip if running via file:// protocol (fetch won't work due to CORS)
            if (window.location.protocol === 'file:') {
                const skipContainer = document.createElement('div');
                skipContainer.className = 'test-suite';
                skipContainer.innerHTML = `
                    <h2>HTML Page Validation <span class="module-badge">Skipped</span></h2>
                    <div class="test-case" style="background: rgba(251, 191, 36, 0.1); border-left: 4px solid #fbbf24;">
                        <span>‚ö†Ô∏è HTML validation tests require HTTP server. Run <code>serve.ps1</code> and open <code>http://localhost:8080/tests/</code> to run these tests locally.</span>
                        <span class="test-status" style="color: #fbbf24;">SKIPPED</span>
                    </div>
                `;
                document.getElementById('test-results').appendChild(skipContainer);
                console.log('HTML validation tests skipped (file:// protocol)');
                return;
            }

            const armResults = [];
            const reportResults = [];
            
            // Test ARM page
            const armValidation = await validateHtmlPage('../arm/arm.html', 'ARM Page', [
                'head', 'body', 'title', '.page-header-bar', '.page-header-logo', '.page-header-logo img', 'main.container'
            ]);
            
            armResults.push(assert(armValidation.success, 'ARM page loads without errors', true, armValidation.success ? true : armValidation.error));
            
            if (armValidation.success) {
                // Check logo image path
                const logoImg = armValidation.doc.querySelector('.page-header-logo img');
                const logoSrc = logoImg ? logoImg.getAttribute('src') : null;
                armResults.push(assert(logoSrc === '../images/odin-logo.png', 'ARM logo path correct', '../images/odin-logo.png', logoSrc));
                
                // Check stylesheet link
                const styleLink = armValidation.doc.querySelector('link[rel="stylesheet"]');
                const styleSrc = styleLink ? styleLink.getAttribute('href') : null;
                armResults.push(assert(styleSrc === '../css/style.css', 'ARM stylesheet path correct', '../css/style.css', styleSrc));
                
                // Check header bar link
                const headerLink = armValidation.doc.querySelector('.page-header-logo');
                const headerHref = headerLink ? headerLink.getAttribute('href') : null;
                armResults.push(assert(headerHref === '../', 'ARM header link correct', '../', headerHref));
            }
            
            testSuite('ARM Page Validation', 'arm/arm.html', armResults);
            
            // Test Report page
            const reportValidation = await validateHtmlPage('../report/report.html', 'Report Page', [
                'head', 'body', 'title', '.page-header-bar', '.page-header-logo', '.page-header-logo img', 'main.container'
            ]);
            
            reportResults.push(assert(reportValidation.success, 'Report page loads without errors', true, reportValidation.success ? true : reportValidation.error));
            
            if (reportValidation.success) {
                // Check logo image path
                const logoImg = reportValidation.doc.querySelector('.page-header-logo img');
                const logoSrc = logoImg ? logoImg.getAttribute('src') : null;
                reportResults.push(assert(logoSrc === '../images/odin-logo.png', 'Report logo path correct', '../images/odin-logo.png', logoSrc));
                
                // Check stylesheet link
                const styleLink = reportValidation.doc.querySelector('link[rel="stylesheet"]');
                const styleSrc = styleLink ? styleLink.getAttribute('href') : null;
                reportResults.push(assert(styleSrc === '../css/style.css', 'Report stylesheet path correct', '../css/style.css', styleSrc));
                
                // Check header bar link
                const headerLink = reportValidation.doc.querySelector('.page-header-logo');
                const headerHref = headerLink ? headerLink.getAttribute('href') : null;
                reportResults.push(assert(headerHref === '../', 'Report header link correct', '../', headerHref));
                
                // Check report has no-print class on header bar
                const headerBar = reportValidation.doc.querySelector('.page-header-bar');
                const hasNoPrint = headerBar ? headerBar.classList.contains('no-print') : false;
                reportResults.push(assert(hasNoPrint, 'Report header bar has no-print class', true, hasNoPrint));
            }
            
            testSuite('Report Page Validation', 'report/report.html', reportResults);
            
            // Update summary after async tests complete
            updateTestSummary();
        })();

        // ========================================================================
        // JS/SCRIPT.JS TESTS - PORT CONFIGURATION VALIDATION
        // ========================================================================
        sectionHeader('üîå js/script.js - Port Configuration Validation');

        // Test: getDuplicateAdapterNameIndices
        testSuite('getDuplicateAdapterNameIndices()', 'script.js', [
            (function() {
                // Save original state
                const origPortConfig = state.portConfig;
                
                // Test: No duplicates with default names
                state.portConfig = [
                    { customName: null, speed: '25GbE', rdma: true },
                    { customName: null, speed: '25GbE', rdma: true }
                ];
                const noDupes = getDuplicateAdapterNameIndices();
                state.portConfig = origPortConfig;
                return assert(noDupes.size === 0, 'No duplicates with default names (Port 1, Port 2)', 0, noDupes.size);
            })(),
            (function() {
                const origPortConfig = state.portConfig;
                
                // Test: Duplicate custom names
                state.portConfig = [
                    { customName: 'Ethernet1', speed: '25GbE', rdma: true },
                    { customName: 'Ethernet1', speed: '25GbE', rdma: true }
                ];
                const dupes = getDuplicateAdapterNameIndices();
                state.portConfig = origPortConfig;
                return assert(dupes.size === 2, 'Detects duplicate custom names', 2, dupes.size);
            })(),
            (function() {
                const origPortConfig = state.portConfig;
                
                // Test: Case-insensitive duplicate detection
                state.portConfig = [
                    { customName: 'Ethernet1', speed: '25GbE', rdma: true },
                    { customName: 'ETHERNET1', speed: '25GbE', rdma: true }
                ];
                const dupes = getDuplicateAdapterNameIndices();
                state.portConfig = origPortConfig;
                return assert(dupes.size === 2, 'Case-insensitive duplicate detection', 2, dupes.size);
            })(),
            (function() {
                const origPortConfig = state.portConfig;
                
                // Test: Mixed unique names
                state.portConfig = [
                    { customName: 'Mgmt1', speed: '25GbE', rdma: false },
                    { customName: 'Storage1', speed: '25GbE', rdma: true },
                    { customName: 'Storage2', speed: '25GbE', rdma: true },
                    { customName: 'Compute1', speed: '25GbE', rdma: false }
                ];
                const dupes = getDuplicateAdapterNameIndices();
                state.portConfig = origPortConfig;
                return assert(dupes.size === 0, 'No duplicates with unique custom names', 0, dupes.size);
            })(),
            (function() {
                const origPortConfig = state.portConfig;
                
                // Test: Three-way duplicate
                state.portConfig = [
                    { customName: 'NIC1', speed: '25GbE', rdma: true },
                    { customName: 'NIC1', speed: '25GbE', rdma: true },
                    { customName: 'NIC1', speed: '25GbE', rdma: true },
                    { customName: 'NIC2', speed: '25GbE', rdma: true }
                ];
                const dupes = getDuplicateAdapterNameIndices();
                state.portConfig = origPortConfig;
                return assert(dupes.size === 3, 'Detects three-way duplicate', 3, dupes.size);
            })(),
            (function() {
                const origPortConfig = state.portConfig;
                
                // Test: Returns correct indices
                state.portConfig = [
                    { customName: 'UniqueA', speed: '25GbE', rdma: true },
                    { customName: 'Duplicate', speed: '25GbE', rdma: true },
                    { customName: 'UniqueB', speed: '25GbE', rdma: true },
                    { customName: 'Duplicate', speed: '25GbE', rdma: true }
                ];
                const dupes = getDuplicateAdapterNameIndices();
                const hasIdx1 = dupes.has(1);
                const hasIdx3 = dupes.has(3);
                const notHasIdx0 = !dupes.has(0);
                const notHasIdx2 = !dupes.has(2);
                state.portConfig = origPortConfig;
                return assert(hasIdx1 && hasIdx3 && notHasIdx0 && notHasIdx2, 
                    'Returns correct duplicate indices (1, 3)', 
                    'indices 1,3', 
                    Array.from(dupes).sort().join(','));
            })()
        ]);

        // ========================================================================
        // JS/SCRIPT.JS TESTS - IMPORT/EXPORT CONFIGURATION
        // ========================================================================
        sectionHeader('üì• js/script.js - Import/Export Configuration');

        // Test: exportConfiguration output structure
        testSuite('exportConfiguration() - Output Structure', 'script.js', [
            (function() {
                // Mock the original state and functions needed
                const mockState = {...state};
                const mockDateNow = Date.now;
                Date.now = () => 1700000000000; // Fixed timestamp for testing
                
                // Create a mock export similar to what exportConfiguration produces
                const exportData = {
                    version: '0.12.0',
                    exportedAt: new Date().toISOString(),
                    state: mockState
                };
                
                Date.now = mockDateNow; // Restore
                
                return assert(
                    exportData.version !== undefined && exportData.exportedAt !== undefined && exportData.state !== undefined,
                    'Export contains version, exportedAt, and state',
                    true,
                    exportData.version !== undefined && exportData.exportedAt !== undefined && exportData.state !== undefined
                );
            })(),
            (function() {
                // Verify state object has all expected fields
                const expectedFields = [
                    'scenario', 'region', 'localInstanceRegion', 'scale', 'nodes', 'witnessType',
                    'theme', 'fontSize', 'ports', 'portConfig', 'storage', 'torSwitchCount',
                    'switchlessLinkMode', 'storagePoolConfiguration', 'rackAwareZones',
                    'intent', 'outbound', 'arc', 'proxy', 'ip', 'infra', 'infraCidr',
                    'infraGateway', 'nodeSettings', 'infraVlan', 'storageAutoIp',
                    'activeDirectory', 'adDomain', 'adOuPath', 'dnsServers', 'localDnsZone',
                    'sdnEnabled', 'sdnFeatures', 'sdnManagement', 'intentOverrides', 'customIntents',
                    'adapterMapping', 'securityConfiguration', 'securitySettings',
                    'privateEndpoints', 'privateEndpointsList'
                ];
                const stateFields = Object.keys(state);
                const missingFields = expectedFields.filter(f => !stateFields.includes(f));
                return assert(
                    missingFields.length === 0,
                    'State object contains all expected wizard fields (' + expectedFields.length + ' fields)',
                    '[]',
                    JSON.stringify(missingFields)
                );
            })()
        ]);

        // Test: parseArmTemplateToState - ARM template detection
        testSuite('parseArmTemplateToState() - ARM Template Detection', 'script.js', [
            (function() {
                // Valid ARM template schema
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result !== null, 'Detects valid ARM template (deploymentTemplate schema)', 'not null', result !== null ? 'object' : 'null');
            })(),
            (function() {
                // Valid ARM parameters file schema
                const armParams = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armParams);
                return assert(result !== null, 'Detects valid ARM parameters file', 'not null', result !== null ? 'object' : 'null');
            })(),
            (function() {
                // Non-ARM JSON (Odin export)
                const odinExport = {
                    "version": "0.12.0",
                    "state": { "scenario": "hyperconverged" }
                };
                const result = parseArmTemplateToState(odinExport);
                return assert(result === null, 'Returns null for non-ARM JSON (Odin export)', 'null', result === null ? 'null' : 'object');
            })(),
            (function() {
                // Invalid schema
                const invalidJson = {
                    "$schema": "https://example.com/invalid-schema.json",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(invalidJson);
                return assert(result === null, 'Returns null for invalid schema', 'null', result === null ? 'null' : 'object');
            })()
        ]);

        // Test: parseArmTemplateToState - Node extraction
        testSuite('parseArmTemplateToState() - Node Count Extraction', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "arcNodeResourceIds": {
                            "value": ["/subscriptions/xxx/node1", "/subscriptions/xxx/node2", "/subscriptions/xxx/node3"]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.nodes === '3', 'Extracts node count from arcNodeResourceIds array', '3', result.nodes);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "physicalNodesSettings": {
                            "value": [
                                { "name": "Node1", "ipv4Address": "10.0.0.1" },
                                { "name": "Node2", "ipv4Address": "10.0.0.2" }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.nodes === '2', 'Extracts node count from physicalNodesSettings array', '2', result.nodes);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "physicalNodesSettings": {
                            "value": [
                                { "name": "Node1", "ipv4Address": "10.0.0.1" },
                                { "name": "Node2", "ipv4Address": "10.0.0.2" }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const hasNodeSettings = result.nodeSettings && result.nodeSettings.length === 2;
                const firstNode = hasNodeSettings ? result.nodeSettings[0] : null;
                return assert(
                    hasNodeSettings && firstNode.name === 'Node1',
                    'Extracts node names from physicalNodesSettings',
                    'Node1',
                    firstNode ? firstNode.name : 'undefined'
                );
            })()
        ]);

        // Test: parseArmTemplateToState - Network settings extraction
        testSuite('parseArmTemplateToState() - Network Settings', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "domainFqdn": { "value": "contoso.local" },
                        "dnsServers": { "value": ["10.0.0.1", "10.0.0.2"] }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.adDomain === 'contoso.local', 'Extracts domain FQDN', 'contoso.local', result.adDomain);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "dnsServers": { "value": ["10.0.0.1", "10.0.0.2"] }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const dnsMatches = result.dnsServers && result.dnsServers.length === 2 && result.dnsServers[0] === '10.0.0.1';
                return assert(dnsMatches, 'Extracts DNS servers array', '["10.0.0.1","10.0.0.2"]', JSON.stringify(result.dnsServers));
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "defaultGateway": { "value": "192.168.1.1" }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.infraGateway === '192.168.1.1', 'Extracts default gateway', '192.168.1.1', result.infraGateway);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "witnessType": { "value": "Cloud" }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.witnessType === 'Cloud', 'Extracts witness type', 'Cloud', result.witnessType);
            })()
        ]);

        // Test: parseArmTemplateToState - Default values for missing ARM fields
        testSuite('parseArmTemplateToState() - Default Values for Missing Fields', 'script.js', [
            (function() {
                // Minimal ARM template - should get defaults
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.region === 'azure_commercial', 'Defaults region to azure_commercial', 'azure_commercial', result.region);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.localInstanceRegion === 'east_us', 'Defaults localInstanceRegion to east_us', 'east_us', result.localInstanceRegion);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.scale === 'medium', 'Defaults scale to medium (hyperconverged)', 'medium', result.scale);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.outbound === 'public', 'Defaults outbound to public', 'public', result.outbound);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armTemplate);
                // Note: ARM imports should prompt for arc/proxy/privateEndpoints via dialog
                // The parseArmTemplateToState sets defaults that may be overridden by dialog
                return assert(result.arc === 'yes' || result.arc === 'no_arc', 'Sets default arc value', 'yes or no_arc', result.arc);
            })()
        ]);

        // Test: parseArmTemplateToState - Storage configuration
        testSuite('parseArmTemplateToState() - Storage Configuration', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "storageConnectivitySwitchless": { "value": true }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.storage === 'switchless', 'Extracts switchless storage from storageConnectivitySwitchless=true', 'switchless', result.storage);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "storageConnectivitySwitchless": { "value": false }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.storage === 'switched', 'Extracts switched storage from storageConnectivitySwitchless=false', 'switched', result.storage);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "enableStorageAutoIp": { "value": true }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.storageAutoIp === 'enabled', 'Extracts storage auto IP enabled', 'enabled', result.storageAutoIp);
            })()
        ]);

        // Test: parseArmTemplateToState - Intent and Port mapping
        testSuite('parseArmTemplateToState() - Intent and Port Mapping', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "networkingPattern": { "value": "convergedManagementCompute" }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.intent === 'mgmt_compute', 'Maps networkingPattern convergedManagementCompute to mgmt_compute', 'mgmt_compute', result.intent);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "networkingPattern": { "value": "hyperConverged" }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.intent === 'all_traffic', 'Maps networkingPattern hyperConverged to all_traffic', 'all_traffic', result.intent);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["NIC1", "NIC2"], "trafficType": ["Management", "Compute"] },
                                { "adapter": ["SMB1", "SMB2"], "trafficType": ["Storage"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                // Should extract 4 total ports (2 NIC + 2 SMB)
                return assert(result.ports === '4', 'Extracts port count from intentList (NIC + SMB adapters)', '4', result.ports);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["Ethernet1", "Ethernet2"], "trafficType": ["Management", "Compute"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                // Should preserve custom adapter names
                const hasCustomName = result.portConfig && result.portConfig[0] && result.portConfig[0].customName === 'Ethernet1';
                return assert(hasCustomName, 'Preserves custom adapter names from intentList', 'Ethernet1', result.portConfig?.[0]?.customName || 'undefined');
            })()
        ]);

        // Test: parseArmTemplateToState - Intent override from intentList traffic types
        testSuite('parseArmTemplateToState() - Intent Override from IntentList', 'script.js', [
            (function() {
                // networkingPattern says hyperConverged but intentList has 2 intents (Mgmt+Compute & Storage)
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "networkingPattern": { "value": "hyperConverged" },
                        "intentList": {
                            "value": [
                                { "name": "HCI", "adapter": ["Port3", "Port2"], "trafficType": ["Management", "Compute"] },
                                { "name": "Storage", "adapter": ["Port0", "Port1"], "trafficType": ["Storage"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.intent === 'mgmt_compute', 'Overrides hyperConverged to mgmt_compute when intentList has Mgmt+Compute & Storage intents', 'mgmt_compute', result.intent);
            })(),
            (function() {
                // networkingPattern says hyperConverged and intentList confirms single all-traffic intent
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "networkingPattern": { "value": "hyperConverged" },
                        "intentList": {
                            "value": [
                                { "name": "HCI", "adapter": ["Port1", "Port2"], "trafficType": ["Management", "Compute", "Storage"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.intent === 'all_traffic', 'Keeps all_traffic when intentList confirms single all-traffic intent', 'all_traffic', result.intent);
            })(),
            (function() {
                // Compute+Storage and Management separate
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["NIC1", "NIC2"], "trafficType": ["Compute", "Storage"] },
                                { "adapter": ["NIC3"], "trafficType": ["Management"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.intent === 'compute_storage', 'Detects compute_storage intent from intentList', 'compute_storage', result.intent);
            })(),
            (function() {
                // 3+ intents should map to custom
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["NIC1"], "trafficType": ["Management"] },
                                { "adapter": ["NIC2"], "trafficType": ["Compute"] },
                                { "adapter": ["NIC3"], "trafficType": ["Storage"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.intent === 'custom', 'Maps 3+ intents to custom', 'custom', result.intent);
            })()
        ]);

        // Test: parseArmTemplateToState - Rack Aware and Local Availability Zones
        testSuite('parseArmTemplateToState() - Rack Aware Import', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "clusterPattern": { "value": "RackAware" },
                        "physicalNodesSettings": {
                            "value": [
                                { "name": "Node1", "ipv4Address": "10.0.0.1" },
                                { "name": "Node2", "ipv4Address": "10.0.0.2" },
                                { "name": "Node3", "ipv4Address": "10.0.0.3" },
                                { "name": "Node4", "ipv4Address": "10.0.0.4" }
                            ]
                        },
                        "localAvailabilityZones": {
                            "value": [
                                { "localAvailabilityZoneName": "Rack-A", "nodes": ["Node1", "Node2"] },
                                { "localAvailabilityZoneName": "Rack-B", "nodes": ["Node3", "Node4"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.scale === 'rack_aware', 'Sets scale to rack_aware for RackAware clusterPattern', 'rack_aware', result.scale);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "clusterPattern": { "value": "RackAware" },
                        "physicalNodesSettings": {
                            "value": [
                                { "name": "Node1", "ipv4Address": "10.0.0.1" },
                                { "name": "Node2", "ipv4Address": "10.0.0.2" },
                                { "name": "Node3", "ipv4Address": "10.0.0.3" },
                                { "name": "Node4", "ipv4Address": "10.0.0.4" }
                            ]
                        },
                        "localAvailabilityZones": {
                            "value": [
                                { "localAvailabilityZoneName": "Rack-A", "nodes": ["Node1", "Node2"] },
                                { "localAvailabilityZoneName": "Rack-B", "nodes": ["Node3", "Node4"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const z = result.rackAwareZones;
                return assert(z && z.zone1Name === 'Rack-A' && z.zone2Name === 'Rack-B', 'Imports zone names from localAvailabilityZones', 'Rack-A / Rack-B', z ? `${z.zone1Name} / ${z.zone2Name}` : 'undefined');
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "clusterPattern": { "value": "RackAware" },
                        "physicalNodesSettings": {
                            "value": [
                                { "name": "Node1", "ipv4Address": "10.0.0.1" },
                                { "name": "Node2", "ipv4Address": "10.0.0.2" },
                                { "name": "Node3", "ipv4Address": "10.0.0.3" },
                                { "name": "Node4", "ipv4Address": "10.0.0.4" }
                            ]
                        },
                        "localAvailabilityZones": {
                            "value": [
                                { "localAvailabilityZoneName": "Rack-A", "nodes": ["Node1", "Node2"] },
                                { "localAvailabilityZoneName": "Rack-B", "nodes": ["Node3", "Node4"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const z = result.rackAwareZones;
                const assignments = z ? z.assignments : {};
                const correct = assignments[1] === 1 && assignments[2] === 1 && assignments[3] === 2 && assignments[4] === 2;
                return assert(correct, 'Maps node assignments to correct zones (Nodes 1-2 ‚Üí Zone1, Nodes 3-4 ‚Üí Zone2)', '{1:1,2:1,3:2,4:2}', JSON.stringify(assignments));
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "clusterPattern": { "value": "RackAware" },
                        "physicalNodesSettings": {
                            "value": [
                                { "name": "Node1", "ipv4Address": "10.0.0.1" },
                                { "name": "Node2", "ipv4Address": "10.0.0.2" }
                            ]
                        },
                        "localAvailabilityZones": {
                            "value": [
                                { "localAvailabilityZoneName": "Zone1", "nodes": ["Node1"] },
                                { "localAvailabilityZoneName": "Zone2", "nodes": ["Node2"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.rackAwareZonesConfirmed === true, 'Auto-confirms rack aware zones on import', true, result.rackAwareZonesConfirmed);
            })()
        ]);

        // Test: parseArmTemplateToState - Storage VLAN import from storageNetworkList
        testSuite('parseArmTemplateToState() - Storage VLAN Import', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["NIC1", "NIC2"], "trafficType": ["Management", "Compute"] },
                                { "adapter": ["SMB1", "SMB2"], "trafficType": ["Storage"] }
                            ]
                        },
                        "storageNetworkList": {
                            "value": [
                                { "name": "StorageNetwork1", "networkAdapterName": "SMB1", "vlanId": "21" },
                                { "name": "StorageNetwork2", "networkAdapterName": "SMB2", "vlanId": "22" }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const ov = result.intentOverrides && result.intentOverrides['storage'];
                return assert(ov && ov.storageNetwork1VlanId === 21, 'Imports storage VLAN 1 from storageNetworkList', 21, ov ? ov.storageNetwork1VlanId : 'undefined');
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["NIC1", "NIC2"], "trafficType": ["Management", "Compute"] },
                                { "adapter": ["SMB1", "SMB2"], "trafficType": ["Storage"] }
                            ]
                        },
                        "storageNetworkList": {
                            "value": [
                                { "name": "StorageNetwork1", "networkAdapterName": "SMB1", "vlanId": "21" },
                                { "name": "StorageNetwork2", "networkAdapterName": "SMB2", "vlanId": "22" }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const ov = result.intentOverrides && result.intentOverrides['storage'];
                return assert(ov && ov.storageNetwork2VlanId === 22, 'Imports storage VLAN 2 from storageNetworkList', 22, ov ? ov.storageNetwork2VlanId : 'undefined');
            })(),
            (function() {
                // All-traffic intent should use 'all' override key
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["NIC1", "NIC2"], "trafficType": ["Management", "Compute", "Storage"] }
                            ]
                        },
                        "storageNetworkList": {
                            "value": [
                                { "name": "StorageNetwork1", "networkAdapterName": "NIC1", "vlanId": "711" },
                                { "name": "StorageNetwork2", "networkAdapterName": "NIC2", "vlanId": "712" }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const ov = result.intentOverrides && result.intentOverrides['all'];
                return assert(ov && ov.storageNetwork1VlanId === 711, 'Uses all override key for all_traffic intent VLANs', 711, ov ? ov.storageNetwork1VlanId : 'undefined');
            })()
        ]);

        // Test: parseArmTemplateToState - Custom storage subnets import
        testSuite('parseArmTemplateToState() - Custom Storage Subnets Import', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "enableStorageAutoIp": { "value": false },
                        "storageNetworkList": {
                            "value": [
                                {
                                    "name": "StorageNetwork1",
                                    "networkAdapterName": "SMB1",
                                    "vlanId": "21",
                                    "storageAdapterIPInfo": [
                                        { "physicalNode": "Node1", "ipv4Address": "172.25.117.160", "subnetMask": "255.255.255.192" }
                                    ]
                                },
                                {
                                    "name": "StorageNetwork2",
                                    "networkAdapterName": "SMB2",
                                    "vlanId": "22",
                                    "storageAdapterIPInfo": [
                                        { "physicalNode": "Node1", "ipv4Address": "172.25.117.240", "subnetMask": "255.255.255.192" }
                                    ]
                                }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const subnets = result.customStorageSubnets;
                return assert(subnets && subnets.length === 2, 'Imports 2 custom storage subnets from storageNetworkList', 2, subnets ? subnets.length : 0);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "enableStorageAutoIp": { "value": false },
                        "storageNetworkList": {
                            "value": [
                                {
                                    "name": "StorageNetwork1",
                                    "networkAdapterName": "SMB1",
                                    "vlanId": "21",
                                    "storageAdapterIPInfo": [
                                        { "physicalNode": "Node1", "ipv4Address": "172.25.117.160", "subnetMask": "255.255.255.192" }
                                    ]
                                }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const subnets = result.customStorageSubnets;
                // 172.25.117.160 with /26 mask ‚Üí network 172.25.117.128/26
                return assert(subnets && subnets[0] === '172.25.117.128/26', 'Calculates correct CIDR from storage IP and subnet mask', '172.25.117.128/26', subnets ? subnets[0] : 'undefined');
            })()
        ]);

        // Test: parseArmTemplateToState - Security settings
        testSuite('parseArmTemplateToState() - Security Settings', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "securityLevel": { "value": "Recommended" }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.securityConfiguration === 'recommended', 'Extracts security level Recommended', 'recommended', result.securityConfiguration);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "bitlockerBootVolume": { "value": false },
                        "bitlockerDataVolumes": { "value": true }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const bootVolume = result.securitySettings && result.securitySettings.bitlockerBootVolume === false;
                const dataVolumes = result.securitySettings && result.securitySettings.bitlockerDataVolumes === true;
                return assert(bootVolume && dataVolumes, 'Extracts individual security settings', 'boot:false, data:true', 
                    `boot:${result.securitySettings?.bitlockerBootVolume}, data:${result.securitySettings?.bitlockerDataVolumes}`);
            })()
        ]);

        // Test: Import handles missing fields gracefully (backward compatibility)
        testSuite('Import Configuration - Backward Compatibility', 'script.js', [
            (function() {
                // Simulate an old export missing new fields like privateEndpoints
                const oldExport = {
                    version: '0.10.0',
                    exportedAt: '2024-01-01T00:00:00Z',
                    state: {
                        scenario: 'hyperconverged',
                        nodes: '3',
                        storage: 'switched'
                        // Missing: privateEndpoints, privateEndpointsList, etc.
                    }
                };
                // Verify the structure is valid even without new fields
                const hasRequiredFields = oldExport.state && oldExport.version;
                return assert(hasRequiredFields, 'Old exports without new fields are valid JSON structure', true, hasRequiredFields);
            })(),
            (function() {
                // Verify current state has all fields that could be missing in old exports
                const newFields = ['privateEndpoints', 'privateEndpointsList', 'rackAwareZones', 'rackAwareTorsPerRoom', 'rackAwareTorArchitecture'];
                const stateHasNewFields = newFields.every(f => f in state);
                return assert(stateHasNewFields, 'Current state defines all new wizard fields', true, stateHasNewFields);
            })()
        ]);

        // Test: State field completeness (ensure new steps automatically included)
        testSuite('State Field Coverage - New Steps Auto-Included', 'script.js', [
            (function() {
                // Critical fields that should be in exports (grouped by wizard step)
                const criticalFields = {
                    // Step 1: Scenario
                    scenario: state.hasOwnProperty('scenario'),
                    // Step 2: Region
                    region: state.hasOwnProperty('region'),
                    localInstanceRegion: state.hasOwnProperty('localInstanceRegion'),
                    // Step 3: Scale
                    scale: state.hasOwnProperty('scale'),
                    // Step 4: Nodes
                    nodes: state.hasOwnProperty('nodes'),
                    // Step 5: Witness
                    witnessType: state.hasOwnProperty('witnessType'),
                    // Networking steps
                    ports: state.hasOwnProperty('ports'),
                    portConfig: state.hasOwnProperty('portConfig'),
                    storage: state.hasOwnProperty('storage'),
                    intent: state.hasOwnProperty('intent'),
                    // Connectivity steps
                    outbound: state.hasOwnProperty('outbound'),
                    arc: state.hasOwnProperty('arc'),
                    proxy: state.hasOwnProperty('proxy'),
                    privateEndpoints: state.hasOwnProperty('privateEndpoints'),
                    // SDN
                    sdnEnabled: state.hasOwnProperty('sdnEnabled'),
                    sdnFeatures: state.hasOwnProperty('sdnFeatures'),
                    // Security
                    securityConfiguration: state.hasOwnProperty('securityConfiguration'),
                    securitySettings: state.hasOwnProperty('securitySettings')
                };
                const missingCritical = Object.entries(criticalFields).filter(([k, v]) => !v).map(([k]) => k);
                return assert(
                    missingCritical.length === 0,
                    'All critical wizard step fields exist in state object',
                    '[]',
                    JSON.stringify(missingCritical)
                );
            })(),
            (function() {
                // Rack-aware fields (newer addition)
                const rackFields = ['rackAwareZones', 'rackAwareTorsPerRoom', 'rackAwareTorArchitecture', 'rackAwareZoneSwapSelection'];
                const hasRackFields = rackFields.every(f => f in state);
                return assert(hasRackFields, 'Rack-aware zone fields exist in state', true, hasRackFields);
            })(),
            (function() {
                // Private endpoint fields (newer addition) 
                const peFields = ['privateEndpoints', 'privateEndpointsList'];
                const hasPeFields = peFields.every(f => f in state);
                return assert(hasPeFields, 'Private endpoint fields exist in state', true, hasPeFields);
            })()
        ]);

        // Test: Detect undocumented state fields (fails when new fields are added without updating this list)
        // PURPOSE: When this test fails, it means a developer added a new field to the state object
        // but hasn't considered import/export functionality. Update the knownFields array below
        // and verify that:
        //   1. exportConfiguration() will include the new field (automatic - exports entire state)
        //   2. importConfiguration() handles missing field gracefully (uses default)
        //   3. parseArmTemplateToState() maps ARM parameter if applicable
        //   4. showArmImportOptionsDialog() prompts user if field isn't in ARM templates
        testSuite('State Field Inventory - Detect Undocumented Fields', 'script.js', [
            (function() {
                // IMPORTANT: When adding new fields to state, add them here and verify import/export handling!
                // This list must match ALL fields in the state object (js/script.js line ~68)
                const knownFields = [
                    // Core wizard state
                    'scenario',
                    'region',
                    'localInstanceRegion',
                    'scale',
                    'nodes',
                    'witnessType',
                    // UI preferences
                    'theme',
                    'fontSize',
                    // Network configuration
                    'ports',
                    'portConfig',
                    'portConfigConfirmed',
                    'storage',
                    'torSwitchCount',
                    'switchlessLinkMode',
                    'storagePoolConfiguration',
                    // Rack-aware zones
                    'rackAwareZones',
                    'rackAwareZonesConfirmed',
                    'rackAwareZoneSwapSelection',
                    'rackAwareTorsPerRoom',
                    'rackAwareTorArchitecture',
                    // Network intents
                    'intent',
                    'customIntentConfirmed',
                    'intentOverrides',
                    'customIntents',
                    'adapterMapping',
                    'adapterMappingConfirmed',
                    'adapterMappingSelection',
                    'overridesConfirmed',
                    // Connectivity
                    'outbound',
                    'arc',
                    'proxy',
                    // IP configuration
                    'ip',
                    'infra',
                    'infraCidr',
                    'infraCidrAuto',
                    'infraGateway',
                    'infraGatewayManual',
                    'nodeSettings',
                    'infraVlan',
                    'infraVlanId',
                    'storageAutoIp',
                    'customStorageSubnets',
                    'customStorageSubnetsConfirmed',
                    // Active Directory
                    'activeDirectory',
                    'adDomain',
                    'adOuPath',
                    'adfsServerName',
                    // DNS
                    'dnsServers',
                    'localDnsZone',
                    'dnsServiceExisting',
                    // SDN
                    'sdnEnabled',
                    'sdnFeatures',
                    'sdnManagement',
                    // Security
                    'securityConfiguration',
                    'securitySettings',
                    'rdmaGuardMessage',
                    // Private endpoints
                    'privateEndpoints',
                    'privateEndpointsList'
                ];
                
                const actualFields = Object.keys(state);
                const undocumented = actualFields.filter(f => !knownFields.includes(f));
                const extraInList = knownFields.filter(f => !actualFields.includes(f));
                
                // Test for undocumented fields (new fields added to state but not to this list)
                // Failure message includes actionable instructions for the developer
                const failureMsg = undocumented.length > 0 
                    ? 'NEW FIELDS DETECTED: ' + JSON.stringify(undocumented) + 
                      ' -- ACTION REQUIRED: (1) Add field to knownFields array in tests/index.html line ~1455, ' +
                      '(2) Verify importConfiguration handles missing field, ' +
                      '(3) Add ARM mapping in parseArmTemplateToState if applicable, ' +
                      '(4) Add prompt in showArmImportOptionsDialog if not in ARM templates'
                    : '[]';
                
                return assert(
                    undocumented.length === 0,
                    'STATE FIELD INVENTORY: All fields documented for import/export',
                    '[]',
                    failureMsg
                );
            })(),
            (function() {
                // Verify the knownFields list doesn't have stale entries
                const knownFields = [
                    'scenario', 'region', 'localInstanceRegion', 'scale', 'nodes', 'witnessType',
                    'theme', 'fontSize', 'ports', 'portConfig', 'portConfigConfirmed', 'storage',
                    'torSwitchCount', 'switchlessLinkMode', 'storagePoolConfiguration',
                    'rackAwareZones', 'rackAwareZonesConfirmed', 'rackAwareZoneSwapSelection',
                    'rackAwareTorsPerRoom', 'rackAwareTorArchitecture', 'intent', 'customIntentConfirmed',
                    'intentOverrides', 'customIntents', 'adapterMapping', 'adapterMappingConfirmed',
                    'adapterMappingSelection', 'overridesConfirmed', 'outbound', 'arc', 'proxy',
                    'ip', 'infra', 'infraCidr', 'infraCidrAuto', 'infraGateway', 'infraGatewayManual',
                    'nodeSettings', 'infraVlan', 'infraVlanId', 'storageAutoIp', 'customStorageSubnets',
                    'customStorageSubnetsConfirmed', 'activeDirectory', 'adDomain', 'adOuPath',
                    'adfsServerName', 'dnsServers', 'localDnsZone', 'dnsServiceExisting',
                    'sdnEnabled', 'sdnFeatures', 'sdnManagement', 'securityConfiguration',
                    'securitySettings', 'rdmaGuardMessage', 'privateEndpoints', 'privateEndpointsList'
                ];
                
                const actualFields = Object.keys(state);
                const staleEntries = knownFields.filter(f => !actualFields.includes(f));
                
                return assert(
                    staleEntries.length === 0,
                    'No stale entries in knownFields (remove fields no longer in state)',
                    '[]',
                    staleEntries.length > 0 ? 'STALE: ' + JSON.stringify(staleEntries) : '[]'
                );
            })()
        ]);

        // ========================================================================
        // REGRESSION TESTS - GitHub Issues #74, #75, #76
        // ========================================================================
        sectionHeader('üêõ Regression Tests - Issues #74, #75, #76');

        // Issue #76: Single-node NIC speed should not be locked at 10 GbE
        testSuite('Issue #76: Single-node NIC speed not locked', 'script.js', [
            (function() {
                // Save original state
                const origNodes = state.nodes;
                const origScale = state.scale;
                const origPortConfig = state.portConfig;

                // Set up single-node standard cluster with existing portConfig at 25GbE
                state.nodes = '1';
                state.scale = 'medium';
                state.portConfig = [
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: null },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: null }
                ];

                // Simulate what the fixed else-branch does: NOT overriding speed
                const pCount = 2;
                const isSingleNode = state.nodes === '1';
                const isLowCapacity = state.scale === 'low_capacity';
                if (isSingleNode && !isLowCapacity) {
                    for (let idx = 0; idx < pCount; idx++) {
                        const pc = state.portConfig[idx];
                        if (!pc) continue;
                        // Speed is NOT overridden (fix for #76)
                        if (!pc.rdmaManual) {
                            pc.rdma = true;
                            pc.rdmaMode = 'RoCEv2';
                        }
                    }
                }

                const speed1 = state.portConfig[0].speed;
                const speed2 = state.portConfig[1].speed;

                // Restore
                state.nodes = origNodes;
                state.scale = origScale;
                state.portConfig = origPortConfig;

                return assert(speed1 === '25GbE' && speed2 === '25GbE',
                    'Single-node: user-selected 25GbE speed preserved (not forced to 10GbE)',
                    '25GbE,25GbE', speed1 + ',' + speed2);
            })()
        ]);

        // Issue #75: VLAN IDs should default to 711/712, not 0
        testSuite('Issue #75: Storage VLAN defaults', 'script.js', [
            (function() {
                // Save original state
                const origOverrides = state.intentOverrides;
                const origIntent = state.intent;

                // Test ensureDefaultOverridesForGroups sets 711/712 correctly
                state.intentOverrides = {};
                state.intent = 'all_traffic';

                const groups = [{ key: 'all', label: 'Group All Traffic', nics: [1, 2] }];
                ensureDefaultOverridesForGroups(groups);

                const v1 = state.intentOverrides['all'].storageNetwork1VlanId;
                const v2 = state.intentOverrides['all'].storageNetwork2VlanId;

                // Restore
                state.intentOverrides = origOverrides;
                state.intent = origIntent;

                return assert(v1 === 711 && v2 === 712,
                    'Default VLAN IDs are 711 and 712 for all_traffic intent',
                    '711,712', v1 + ',' + v2);
            })(),
            (function() {
                // Test that empty string VLAN values are replaced with defaults
                const origOverrides = state.intentOverrides;

                state.intentOverrides = { 'all': { storageNetwork1VlanId: '', storageNetwork2VlanId: '' } };

                const groups = [{ key: 'all', label: 'Group All Traffic', nics: [1, 2] }];
                ensureDefaultOverridesForGroups(groups);

                const v1 = state.intentOverrides['all'].storageNetwork1VlanId;
                const v2 = state.intentOverrides['all'].storageNetwork2VlanId;

                state.intentOverrides = origOverrides;

                return assert(v1 === 711 && v2 === 712,
                    'Empty string VLAN overrides are replaced with defaults (711/712)',
                    '711,712', v1 + ',' + v2);
            })(),
            (function() {
                // Test that zero VLAN values are replaced with defaults
                const origOverrides = state.intentOverrides;

                state.intentOverrides = { 'storage': { storageNetwork1VlanId: 0, storageNetwork2VlanId: 0 } };

                const groups = [{ key: 'storage', label: 'Storage', nics: [3, 4] }];
                ensureDefaultOverridesForGroups(groups);

                const v1 = state.intentOverrides['storage'].storageNetwork1VlanId;
                const v2 = state.intentOverrides['storage'].storageNetwork2VlanId;

                state.intentOverrides = origOverrides;

                return assert(v1 === 711 && v2 === 712,
                    'Zero VLAN overrides are replaced with defaults (711/712)',
                    '711,712', v1 + ',' + v2);
            })(),
            (function() {
                // Test that valid user-set VLAN values are preserved
                const origOverrides = state.intentOverrides;

                state.intentOverrides = { 'all': { storageNetwork1VlanId: 100, storageNetwork2VlanId: 200 } };

                const groups = [{ key: 'all', label: 'Group All Traffic', nics: [1, 2] }];
                ensureDefaultOverridesForGroups(groups);

                const v1 = state.intentOverrides['all'].storageNetwork1VlanId;
                const v2 = state.intentOverrides['all'].storageNetwork2VlanId;

                state.intentOverrides = origOverrides;

                return assert(v1 === 100 && v2 === 200,
                    'User-set VLAN IDs (100/200) are preserved',
                    '100,200', v1 + ',' + v2);
            })()
        ]);

        // Custom intent + adapter mapping confirmed: VLAN IDs should appear in ARM output
        testSuite('Issue #75: Custom intent VLAN IDs in ARM output', 'script.js', [
            (function() {
                const origState = JSON.parse(JSON.stringify(state));
                const origOpen = window.open;
                window.open = function() {};

                // Set up a 3-node custom intent with adapter mapping confirmed
                state.scenario = 'hyperconverged';
                state.region = 'eastus';
                state.localInstanceRegion = 'East US';
                state.scale = 'medium';
                state.nodes = '3';
                state.ports = '4';
                state.storage = 'switched';
                state.storagePoolConfiguration = 'default';
                state.intent = 'custom';
                state.portConfig = [];
                for (let i = 0; i < 4; i++) {
                    state.portConfig.push({ speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: null });
                }
                state.portConfigConfirmed = true;

                // Custom intent: ports 1-2 = mgmt, 3-4 = storage
                state.customIntents = { 1: 'mgmt', 2: 'mgmt', 3: 'storage', 4: 'storage' };
                state.customIntentConfirmed = true;

                // Adapter mapping confirmed (same as customIntents)
                state.adapterMapping = { 1: 'mgmt', 2: 'mgmt', 3: 'storage', 4: 'storage' };
                state.adapterMappingConfirmed = true;

                // Set VLAN IDs via the override key that adapter mapping path uses (unprefixed 'storage')
                state.intentOverrides = {
                    storage: { storageNetwork1VlanId: 711, storageNetwork2VlanId: 714, rdmaMode: 'RoCEv2', jumboFrames: '1514' },
                    mgmt: { rdmaMode: 'RoCEv2', jumboFrames: '1514' }
                };
                state.overridesConfirmed = true;

                state.storageAutoIp = 'enabled';
                state.nodeSettings = [
                    { name: 'node1', ipCidr: '10.0.0.2/24' },
                    { name: 'node2', ipCidr: '10.0.0.3/24' },
                    { name: 'node3', ipCidr: '10.0.0.4/24' }
                ];
                state.witnessType = 'cloud';
                state.ip = 'static';
                state.infraGateway = '10.0.0.1';
                state.outbound = 'proxy';
                state.proxy = 'none';
                state.arc = 'spn';
                state.infra = { start: '10.0.0.100', end: '10.0.0.200' };
                state.infraCidr = '10.0.0.0/24';
                state.infraVlan = 'default';
                state.activeDirectory = 'azure_ad';
                state.adDomain = 'contoso.local';
                state.dnsServers = ['10.0.0.1'];
                state.privateEndpoints = 'no';
                state.securityConfiguration = 'recommended';
                state.securitySettings = {};
                state.sdnEnabled = 'no';

                try {
                    localStorage.removeItem('azloc_arm_payload');
                    generateArmParameters();
                    const raw = localStorage.getItem('azloc_arm_payload');
                    const payload = raw ? JSON.parse(raw) : null;
                    const arm = payload && payload.parametersFile;
                    let result = 'no_vlans';
                    if (arm && arm.parameters && arm.parameters.storageNetworkList && arm.parameters.storageNetworkList.value) {
                        const nets = arm.parameters.storageNetworkList.value;
                        if (nets.length >= 2) {
                            result = nets[0].vlanId + ',' + nets[1].vlanId;
                        }
                    }

                    Object.assign(state, origState);
                    window.open = origOpen;

                    return assert(result === '711,714',
                        'Custom intent + adapter mapping: VLAN IDs 711/714 in ARM output',
                        '711,714', result);
                } catch (e) {
                    Object.assign(state, origState);
                    window.open = origOpen;
                    return assert(false, 'ARM generation did not throw', 'no error', e.message);
                }
            })()
        ]);

        // Issue #74: StorageNetwork2 adapter name should not duplicate StorageNetwork1
        // Test via generateArmParameters() which stores result in localStorage
        testSuite('Issue #74: Storage adapter names in ARM output', 'script.js', [
            (function() {
                // Save original state and override window.open
                const origState = JSON.parse(JSON.stringify(state));
                const origOpen = window.open;
                window.open = function() {}; // prevent opening new window

                // Set up a fully-ready hyper-converged switched cluster
                state.scenario = 'hyperconverged';
                state.region = 'eastus';
                state.localInstanceRegion = 'East US';
                state.scale = 'medium';
                state.nodes = '2';
                state.ports = '2';
                state.storage = 'switched';
                state.storagePoolConfiguration = 'default';
                state.intent = 'all_traffic';
                state.portConfig = [
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: null },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: null }
                ];
                state.portConfigConfirmed = true;
                state.intentOverrides = {};
                state.adapterMappingConfirmed = false;
                state.adapterMapping = {};
                state.storageAutoIp = 'enabled';
                state.nodeSettings = [
                    { name: 'node1', ipCidr: '10.0.0.2/24' },
                    { name: 'node2', ipCidr: '10.0.0.3/24' }
                ];
                state.witnessType = 'cloud';
                state.ip = 'static';
                state.infraGateway = '10.0.0.1';
                state.outbound = 'proxy';
                state.proxy = 'none';
                state.arc = 'spn';
                state.infra = { start: '10.0.0.100', end: '10.0.0.200' };
                state.infraCidr = '10.0.0.0/24';
                state.infraVlan = 'default';
                state.activeDirectory = 'azure_ad';
                state.adDomain = 'contoso.local';
                state.dnsServers = ['10.0.0.1'];
                state.customIntents = {};
                state.privateEndpoints = 'no';
                state.securityConfiguration = 'recommended';
                state.securitySettings = {};
                state.sdnEnabled = 'no';

                try {
                    localStorage.removeItem('azloc_arm_payload');
                    generateArmParameters();
                    const raw = localStorage.getItem('azloc_arm_payload');
                    const payload = raw ? JSON.parse(raw) : null;
                    const arm = payload && payload.parametersFile;
                    let result = 'no_storage_networks';
                    if (arm && arm.parameters && arm.parameters.storageNetworkList && arm.parameters.storageNetworkList.value) {
                        const storageNetworks = arm.parameters.storageNetworkList.value;
                        if (storageNetworks.length >= 2) {
                            result = storageNetworks[0].networkAdapterName + ',' + storageNetworks[1].networkAdapterName;
                        }
                    }

                    Object.assign(state, origState);
                    window.open = origOpen;

                    return assert(result !== 'Port 1,Port 1' && result !== 'no_storage_networks',
                        'StorageNetwork1 and StorageNetwork2 have distinct adapter names',
                        'Port 1,Port 2', result);
                } catch (e) {
                    Object.assign(state, origState);
                    window.open = origOpen;
                    return assert(false, 'ARM generation did not throw', 'no error', e.message);
                }
            })(),
            (function() {
                // Test custom port names flow through to ARM storage adapter names
                const origState = JSON.parse(JSON.stringify(state));
                const origOpen = window.open;
                window.open = function() {};

                state.scenario = 'hyperconverged';
                state.region = 'eastus';
                state.localInstanceRegion = 'East US';
                state.scale = 'medium';
                state.nodes = '2';
                state.ports = '2';
                state.storage = 'switched';
                state.storagePoolConfiguration = 'default';
                state.intent = 'all_traffic';
                state.portConfig = [
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: 'Mellanox-A' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: 'Mellanox-B' }
                ];
                state.portConfigConfirmed = true;
                state.intentOverrides = {};
                state.adapterMappingConfirmed = false;
                state.adapterMapping = {};
                state.storageAutoIp = 'enabled';
                state.nodeSettings = [
                    { name: 'node1', ipCidr: '10.0.0.2/24' },
                    { name: 'node2', ipCidr: '10.0.0.3/24' }
                ];
                state.witnessType = 'cloud';
                state.ip = 'static';
                state.infraGateway = '10.0.0.1';
                state.outbound = 'proxy';
                state.proxy = 'none';
                state.arc = 'spn';
                state.infra = { start: '10.0.0.100', end: '10.0.0.200' };
                state.infraCidr = '10.0.0.0/24';
                state.infraVlan = 'default';
                state.activeDirectory = 'azure_ad';
                state.adDomain = 'contoso.local';
                state.dnsServers = ['10.0.0.1'];
                state.customIntents = {};
                state.privateEndpoints = 'no';
                state.securityConfiguration = 'recommended';
                state.securitySettings = {};
                state.sdnEnabled = 'no';

                try {
                    localStorage.removeItem('azloc_arm_payload');
                    generateArmParameters();
                    const raw = localStorage.getItem('azloc_arm_payload');
                    const payload = raw ? JSON.parse(raw) : null;
                    const arm = payload && payload.parametersFile;
                    let result = 'no_storage_networks';
                    if (arm && arm.parameters && arm.parameters.storageNetworkList && arm.parameters.storageNetworkList.value) {
                        const storageNetworks = arm.parameters.storageNetworkList.value;
                        if (storageNetworks.length >= 2) {
                            result = storageNetworks[0].networkAdapterName + ',' + storageNetworks[1].networkAdapterName;
                        }
                    }

                    Object.assign(state, origState);
                    window.open = origOpen;

                    return assert(result === 'Mellanox-A,Mellanox-B',
                        'Custom port names (Mellanox-A/B) flow to ARM storage network names',
                        'Mellanox-A,Mellanox-B', result);
                } catch (e) {
                    Object.assign(state, origState);
                    window.open = origOpen;
                    return assert(false, 'ARM generation did not throw', 'no error', e.message);
                }
            })()
        ]);

        // Test switchless storage intent adapter names use Port N (not SMB N)
        testSuite('Issue #74: Switchless storage intent adapter names', 'script.js', [
            (function() {
                const origState = JSON.parse(JSON.stringify(state));
                const origOpen = window.open;
                window.open = function() {};

                // Set up a switchless 4-node cluster with 8 ports (2 mgmt + 6 storage)
                state.scenario = 'hyperconverged';
                state.region = 'eastus';
                state.localInstanceRegion = 'East US';
                state.scale = 'medium';
                state.nodes = '4';
                state.ports = '8';
                state.storage = 'switchless';
                state.storagePoolConfiguration = 'default';
                state.intent = 'mgmt_compute';
                state.portConfig = [];
                for (let i = 0; i < 8; i++) {
                    state.portConfig.push({ speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: null });
                }
                state.portConfigConfirmed = true;
                state.intentOverrides = {};
                state.adapterMappingConfirmed = false;
                state.adapterMapping = {};
                state.storageAutoIp = 'enabled';
                state.nodeSettings = [
                    { name: 'node1', ipCidr: '10.0.0.2/24' },
                    { name: 'node2', ipCidr: '10.0.0.3/24' },
                    { name: 'node3', ipCidr: '10.0.0.4/24' },
                    { name: 'node4', ipCidr: '10.0.0.5/24' }
                ];
                state.witnessType = 'cloud';
                state.ip = 'static';
                state.infraGateway = '10.0.0.1';
                state.outbound = 'proxy';
                state.proxy = 'none';
                state.arc = 'spn';
                state.infra = { start: '10.0.0.100', end: '10.0.0.200' };
                state.infraCidr = '10.0.0.0/24';
                state.infraVlan = 'default';
                state.activeDirectory = 'azure_ad';
                state.adDomain = 'contoso.local';
                state.dnsServers = ['10.0.0.1'];
                state.customIntents = {};
                state.privateEndpoints = 'no';
                state.securityConfiguration = 'recommended';
                state.securitySettings = {};
                state.sdnEnabled = 'no';

                try {
                    localStorage.removeItem('azloc_arm_payload');
                    generateArmParameters();
                    const raw = localStorage.getItem('azloc_arm_payload');
                    const payload = raw ? JSON.parse(raw) : null;
                    const arm = payload && payload.parametersFile;
                    let result = 'no_intent_list';
                    if (arm && arm.parameters && arm.parameters.intentList && arm.parameters.intentList.value) {
                        const intents = arm.parameters.intentList.value;
                        const storageIntent = intents.find(i => i.trafficType && i.trafficType.includes('Storage'));
                        if (storageIntent && storageIntent.adapter) {
                            result = storageIntent.adapter.join(',');
                        }
                    }

                    Object.assign(state, origState);
                    window.open = origOpen;

                    // Storage adapter names in the intent should use Port N format, not SMB N
                    const hasSMB = result.includes('SMB');
                    return assert(!hasSMB && result !== 'no_intent_list',
                        'Switchless storage intent adapters use Port N names (not SMB N)',
                        'Port 3,Port 4,Port 5,Port 6,Port 7,Port 8', result);
                } catch (e) {
                    Object.assign(state, origState);
                    window.open = origOpen;
                    return assert(false, 'ARM generation did not throw', 'no error', e.message);
                }
            })()
        ]);

        // ========================================================================
        // REGRESSION TESTS - GitHub Issue #78: IP Address Validation
        // ========================================================================
        sectionHeader('üêõ Regression Tests - Issue #78: IP Address Validation');

        // Test isNetworkOrBroadcastAddress utility
        testSuite('Issue #78: isNetworkOrBroadcastAddress utility', 'utils.js', [
            (function() {
                const result = isNetworkOrBroadcastAddress('192.168.1.0', 24);
                return assert(result === 'network',
                    '192.168.1.0/24 is detected as network address',
                    'network', result);
            })(),
            (function() {
                const result = isNetworkOrBroadcastAddress('192.168.1.255', 24);
                return assert(result === 'broadcast',
                    '192.168.1.255/24 is detected as broadcast address',
                    'broadcast', result);
            })(),
            (function() {
                const result = isNetworkOrBroadcastAddress('192.168.1.1', 24);
                return assert(result === null,
                    '192.168.1.1/24 is a valid host address',
                    'null', String(result));
            })(),
            (function() {
                const result = isNetworkOrBroadcastAddress('10.0.0.0', 8);
                return assert(result === 'network',
                    '10.0.0.0/8 is detected as network address',
                    'network', result);
            })(),
            (function() {
                const result = isNetworkOrBroadcastAddress('10.255.255.255', 8);
                return assert(result === 'broadcast',
                    '10.255.255.255/8 is detected as broadcast address',
                    'broadcast', result);
            })(),
            (function() {
                const result = isNetworkOrBroadcastAddress('10.0.0.1', 32);
                return assert(result === null,
                    '/32 host route is always valid',
                    'null', String(result));
            })()
        ]);

        // Test isLastOctetNetworkOrBroadcast utility
        testSuite('Issue #78: isLastOctetNetworkOrBroadcast utility', 'utils.js', [
            (function() {
                const result = isLastOctetNetworkOrBroadcast('192.168.0.0');
                return assert(result === 'network',
                    'Last octet .0 detected as network',
                    'network', result);
            })(),
            (function() {
                const result = isLastOctetNetworkOrBroadcast('192.168.0.255');
                return assert(result === 'broadcast',
                    'Last octet .255 detected as broadcast',
                    'broadcast', result);
            })(),
            (function() {
                const result = isLastOctetNetworkOrBroadcast('192.168.0.1');
                return assert(result === null,
                    'Last octet .1 is valid host',
                    'null', String(result));
            })(),
            (function() {
                const result = isLastOctetNetworkOrBroadcast('10.0.0.254');
                return assert(result === null,
                    'Last octet .254 is valid host',
                    'null', String(result));
            })()
        ]);

        // Test node IP CIDR validation rejects network/broadcast
        testSuite('Issue #78: Node IP rejects network/broadcast', 'script.js', [
            (function() {
                const origNodes = state.nodes;
                const origIp = state.ip;
                const origSettings = state.nodeSettings;

                state.nodes = '1';
                state.ip = 'static';
                state.nodeSettings = [{ name: 'node1', ipCidr: '192.168.1.0/24' }];
                const readiness = getNodeSettingsReadiness();
                const hasNetworkError = readiness.missing.some(m => m.includes('network address'));

                state.nodes = origNodes;
                state.ip = origIp;
                state.nodeSettings = origSettings;

                return assert(hasNetworkError,
                    'Node with .0/24 IP is rejected as network address',
                    'true', String(hasNetworkError));
            })(),
            (function() {
                const origNodes = state.nodes;
                const origIp = state.ip;
                const origSettings = state.nodeSettings;

                state.nodes = '1';
                state.ip = 'static';
                state.nodeSettings = [{ name: 'node1', ipCidr: '192.168.1.255/24' }];
                const readiness = getNodeSettingsReadiness();
                const hasBroadcastError = readiness.missing.some(m => m.includes('broadcast address'));

                state.nodes = origNodes;
                state.ip = origIp;
                state.nodeSettings = origSettings;

                return assert(hasBroadcastError,
                    'Node with .255/24 IP is rejected as broadcast address',
                    'true', String(hasBroadcastError));
            })(),
            (function() {
                const origNodes = state.nodes;
                const origIp = state.ip;
                const origSettings = state.nodeSettings;

                state.nodes = '1';
                state.ip = 'static';
                state.nodeSettings = [{ name: 'node1', ipCidr: '192.168.1.10/24' }];
                const readiness = getNodeSettingsReadiness();

                state.nodes = origNodes;
                state.ip = origIp;
                state.nodeSettings = origSettings;

                return assert(readiness.ready === true,
                    'Node with .10/24 IP is accepted as valid host',
                    'true', String(readiness.ready));
            })()
        ]);

        // ========================================================================
        // REGRESSION TESTS - GitHub Issue #88: NIC Mapping to Intent
        // ========================================================================
        sectionHeader('üêõ Regression Tests - Issue #88: NIC Mapping to Intent');

        // Test: getMgmtComputeNicAssignment prefers non-RDMA ports for Mgmt+Compute on Low Capacity
        testSuite('Issue #88: getMgmtComputeNicAssignment respects RDMA on Low Capacity', 'script.js', [
            (function() {
                // Setup: Low Capacity, 4 ports, ports 3&4 are RDMA, ports 1&2 are non-RDMA
                const origScale = state.scale;
                const origPorts = state.ports;
                const origPortConfig = state.portConfig;

                state.scale = 'low_capacity';
                state.ports = '4';
                state.portConfig = [
                    { speed: '1GbE', rdma: false, rdmaMode: 'Disabled' },
                    { speed: '1GbE', rdma: false, rdmaMode: 'Disabled' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' }
                ];

                const result = getMgmtComputeNicAssignment(4);

                state.scale = origScale;
                state.ports = origPorts;
                state.portConfig = origPortConfig;

                const mgmtOk = JSON.stringify(result.mgmtCompute) === JSON.stringify([1, 2]);
                const storageOk = JSON.stringify(result.storage) === JSON.stringify([3, 4]);
                return assert(mgmtOk && storageOk,
                    'Non-RDMA ports (1,2) assigned to Mgmt+Compute, RDMA ports (3,4) to Storage',
                    'mgmt:[1,2] storage:[3,4]',
                    'mgmt:[' + result.mgmtCompute + '] storage:[' + result.storage + ']');
            })(),
            (function() {
                // Setup: Low Capacity, 4 ports, ports 1&2 are RDMA, ports 3&4 are non-RDMA
                const origScale = state.scale;
                const origPorts = state.ports;
                const origPortConfig = state.portConfig;

                state.scale = 'low_capacity';
                state.ports = '4';
                state.portConfig = [
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '1GbE', rdma: false, rdmaMode: 'Disabled' },
                    { speed: '1GbE', rdma: false, rdmaMode: 'Disabled' }
                ];

                const result = getMgmtComputeNicAssignment(4);

                state.scale = origScale;
                state.ports = origPorts;
                state.portConfig = origPortConfig;

                const mgmtOk = JSON.stringify(result.mgmtCompute) === JSON.stringify([3, 4]);
                const storageOk = JSON.stringify(result.storage) === JSON.stringify([1, 2]);
                return assert(mgmtOk && storageOk,
                    'RDMA ports (1,2) go to Storage when non-RDMA ports (3,4) available for Mgmt+Compute',
                    'mgmt:[3,4] storage:[1,2]',
                    'mgmt:[' + result.mgmtCompute + '] storage:[' + result.storage + ']');
            })(),
            (function() {
                // Setup: Low Capacity, 4 ports, all RDMA ‚Äî should fallback to [1,2] Mgmt
                const origScale = state.scale;
                const origPorts = state.ports;
                const origPortConfig = state.portConfig;

                state.scale = 'low_capacity';
                state.ports = '4';
                state.portConfig = [
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' }
                ];

                const result = getMgmtComputeNicAssignment(4);

                state.scale = origScale;
                state.ports = origPorts;
                state.portConfig = origPortConfig;

                const mgmtOk = JSON.stringify(result.mgmtCompute) === JSON.stringify([1, 2]);
                const storageOk = JSON.stringify(result.storage) === JSON.stringify([3, 4]);
                return assert(mgmtOk && storageOk && result.allRdma === true,
                    'All-RDMA config: ports 1,2 to Mgmt+Compute, ports 3,4 to Storage',
                    'mgmt:[1,2] storage:[3,4] allRdma:true',
                    'mgmt:[' + result.mgmtCompute + '] storage:[' + result.storage + '] allRdma:' + result.allRdma);
            })()
        ]);

        // Test: getIntentNicGroups matches getDefaultAdapterMapping for Low Capacity mgmt_compute
        testSuite('Issue #88: NIC groups consistent with adapter mapping defaults', 'script.js', [
            (function() {
                // Verify getIntentNicGroups and getDefaultAdapterMapping produce consistent
                // port assignments for mgmt_compute intent on Low Capacity.
                const origScale = state.scale;
                const origPorts = state.ports;
                const origPortConfig = state.portConfig;
                const origIntent = state.intent;
                const origMapping = state.adapterMapping;
                const origConfirmed = state.adapterMappingConfirmed;

                state.scale = 'low_capacity';
                state.ports = '4';
                state.intent = 'mgmt_compute';
                state.portConfig = [
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '1GbE', rdma: false, rdmaMode: 'Disabled' },
                    { speed: '1GbE', rdma: false, rdmaMode: 'Disabled' }
                ];
                state.adapterMapping = {};
                state.adapterMappingConfirmed = false;

                // getIntentNicGroups fallback (no confirmed mapping)
                const nicGroups = getIntentNicGroups('mgmt_compute', 4);
                const mgmtGroup = nicGroups.find(g => g.key === 'mgmt_compute');
                const storageGroup = nicGroups.find(g => g.key === 'storage');

                // getDefaultAdapterMapping
                const defaultMapping = getDefaultAdapterMapping('mgmt_compute', 4);
                const defaultMgmt = [];
                const defaultStorage = [];
                for (let i = 1; i <= 4; i++) {
                    if (defaultMapping[i] === 'mgmt_compute') defaultMgmt.push(i);
                    if (defaultMapping[i] === 'storage') defaultStorage.push(i);
                }

                state.scale = origScale;
                state.ports = origPorts;
                state.portConfig = origPortConfig;
                state.intent = origIntent;
                state.adapterMapping = origMapping;
                state.adapterMappingConfirmed = origConfirmed;

                const groupMgmt = mgmtGroup ? JSON.stringify(mgmtGroup.nics) : '[]';
                const groupStorage = storageGroup ? JSON.stringify(storageGroup.nics) : '[]';
                const mapMgmt = JSON.stringify(defaultMgmt);
                const mapStorage = JSON.stringify(defaultStorage);

                const consistent = groupMgmt === mapMgmt && groupStorage === mapStorage;
                return assert(consistent,
                    'NIC groups and default adapter mapping agree on port assignments',
                    'groups:' + mapMgmt + '/' + mapStorage,
                    'groups:' + groupMgmt + '/' + groupStorage);
            })()
        ]);

        // ========================================================================
        // FINAL SUMMARY
        // ========================================================================
        updateTestSummary();
        
        setTimeout(() => {
            if (failCount === 0) {
                document.body.style.borderTop = '5px solid #10b981';
                console.log(`‚úì All ${totalCount} tests passed!`);
            } else {
                document.body.style.borderTop = '5px solid #ef4444';
                console.log(`‚úó ${failCount} of ${totalCount} test(s) failed`);
            }
        }, 100);
    </script>
</body>
</html>
