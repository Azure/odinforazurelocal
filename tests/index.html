<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit Tests - Azure Local Wizard</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background: #0a0e27;
            color: #e0e7ff;
        }
        h1 { color: #60a5fa; }
        .test-suite {
            background: #1a1f3a;
            border: 1px solid #2d3653;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .test-suite h2 {
            color: #60a5fa;
            margin-top: 0;
            font-size: 1.1rem;
        }
        .test-case {
            padding: 8px 12px;
            margin: 6px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }
        .test-case.pass {
            background: rgba(16, 185, 129, 0.1);
            border-left: 4px solid #10b981;
        }
        .test-case.fail {
            background: rgba(239, 68, 68, 0.1);
            border-left: 4px solid #ef4444;
        }
        .test-status {
            font-weight: bold;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
        }
        .test-status.pass { color: #10b981; }
        .test-status.fail { color: #ef4444; }
        .summary {
            background: linear-gradient(135deg, #1a1f3a, #2d3653);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 24px;
            text-align: center;
            border: 1px solid #3d4663;
        }
        .summary-stat {
            display: inline-block;
            margin: 0 24px;
            font-size: 16px;
        }
        .summary-stat .number {
            font-size: 36px;
            font-weight: bold;
            display: block;
        }
        .summary-stat.pass .number { color: #10b981; }
        .summary-stat.fail .number { color: #ef4444; }
        .module-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            margin-left: 8px;
            background: rgba(96, 165, 250, 0.2);
            color: #60a5fa;
        }
        .section-header {
            background: #2d3653;
            padding: 12px 16px;
            border-radius: 8px;
            margin: 24px 0 16px 0;
            font-size: 1.2rem;
            font-weight: 600;
            color: #a5b4fc;
        }
    </style>
</head>
<body>
    <h1>üß™ Unit Tests - Azure Local Wizard</h1>
    <p>Comprehensive test suite for ODIN modular JavaScript functions</p>
    
    <div id="summary" class="summary">
        <div class="summary-stat pass">
            <span class="number" id="pass-count">0</span>
            <span>Passed</span>
        </div>
        <div class="summary-stat fail">
            <span class="number" id="fail-count">0</span>
            <span>Failed</span>
        </div>
        <div class="summary-stat">
            <span class="number" id="total-count">0</span>
            <span>Total</span>
        </div>
    </div>
    
    <div id="test-results"></div>
    
    <!-- Modular JavaScript files (load before main script.js) -->
    <script src="../js/utils.js"></script>
    <script src="../js/notifications.js"></script>
    <script src="../js/analytics.js"></script>
    <script src="../js/theme.js"></script>
    <script src="../js/formatting.js"></script>
    <script src="../js/validation.js"></script>
    <script src="../js/dns.js"></script>
    <script src="../js/changelog.js"></script>
    <script src="../js/script.js"></script>
    <!-- Enable test mode before loading sizer (skips DOMContentLoaded UI init) -->
    <script>window.__SIZER_TEST_MODE__ = true;</script>
    <script src="../sizer/sizer.js"></script>
    <script>
        // ========================================================================
        // TEST FRAMEWORK
        // ========================================================================
        // Override alert() to prevent headless Chrome hangs during ARM generation tests
        window.alert = function() {};

        let passCount = 0;
        let failCount = 0;
        let totalCount = 0;
        
        // Structured test results for CI/CD extraction (JUnit XML generation)
        window.testResults = [];
        let currentSuite = null;
        let currentSection = null;
        
        function assert(condition, testName, expected, actual) {
            totalCount++;
            const testCase = document.createElement('div');
            testCase.className = 'test-case';
            
            // Store structured result for CI extraction
            const result = {
                name: testName,
                suite: currentSuite || 'Default',
                section: currentSection || 'Tests',
                passed: condition,
                expected: String(expected),
                actual: String(actual),
                timestamp: new Date().toISOString()
            };
            window.testResults.push(result);
            
            if (condition) {
                passCount++;
                testCase.classList.add('pass');
                testCase.innerHTML = `
                    <span>${testName}</span>
                    <span class="test-status pass">‚úì PASS</span>
                `;
            } else {
                failCount++;
                testCase.classList.add('fail');
                testCase.innerHTML = `
                    <span>${testName}<br><small style="color:#f87171;">Expected: ${expected}, Got: ${actual}</small></span>
                    <span class="test-status fail">‚úó FAIL</span>
                `;
            }
            
            return testCase;
        }
        
        function testSuite(name, moduleName, tests) {
            currentSuite = `${name} (${moduleName})`;
            const suite = document.createElement('div');
            suite.className = 'test-suite';
            suite.innerHTML = `<h2>${name} <span class="module-badge">${moduleName}</span></h2>`;
            
            tests.forEach(test => {
                if (test) suite.appendChild(test);
            });
            
            document.getElementById('test-results').appendChild(suite);
        }
        
        function sectionHeader(title) {
            currentSection = title.replace(/[^\w\s]/g, '').trim();
            const header = document.createElement('div');
            header.className = 'section-header';
            header.textContent = title;
            document.getElementById('test-results').appendChild(header);
        }
        
        function updateTestSummary() {
            document.getElementById('pass-count').textContent = passCount;
            document.getElementById('fail-count').textContent = failCount;
            document.getElementById('total-count').textContent = totalCount;
        }

        // ========================================================================
        // JS/UTILS.JS TESTS
        // ========================================================================
        sectionHeader('üì¶ js/utils.js - Core Utilities');
        
        // Test: isValidNetbiosName
        testSuite('isValidNetbiosName()', 'utils.js', [
            assert(isValidNetbiosName('SERVER01') === true, 'Valid: SERVER01', true, isValidNetbiosName('SERVER01')),
            assert(isValidNetbiosName('Node-1') === true, 'Valid: Node-1 (with hyphen)', true, isValidNetbiosName('Node-1')),
            assert(isValidNetbiosName('A') === true, 'Valid: Single character', true, isValidNetbiosName('A')),
            assert(isValidNetbiosName('AAAAAAAAAAAAAAA') === true, 'Valid: 15 characters (max)', true, isValidNetbiosName('AAAAAAAAAAAAAAA')),
            assert(isValidNetbiosName('A-B') === true, 'Valid: 3 chars with hyphen', true, isValidNetbiosName('A-B')),
            assert(isValidNetbiosName('-SERVER') === false, 'Invalid: Starts with hyphen', false, isValidNetbiosName('-SERVER')),
            assert(isValidNetbiosName('SERVER-') === false, 'Invalid: Ends with hyphen', false, isValidNetbiosName('SERVER-')),
            assert(isValidNetbiosName('AAAAAAAAAAAAAAAA') === false, 'Invalid: 16 characters (too long)', false, isValidNetbiosName('AAAAAAAAAAAAAAAA')),
            assert(isValidNetbiosName('') === false, 'Invalid: Empty string', false, isValidNetbiosName('')),
            assert(isValidNetbiosName('Server 01') === false, 'Invalid: Contains space', false, isValidNetbiosName('Server 01')),
            assert(isValidNetbiosName('Server_01') === false, 'Invalid: Contains underscore', false, isValidNetbiosName('Server_01')),
            assert(isValidNetbiosName(null) === false, 'Invalid: null', false, isValidNetbiosName(null)),
            assert(isValidNetbiosName(undefined) === false, 'Invalid: undefined', false, isValidNetbiosName(undefined))
        ]);
        
        // Test: isValidIpv4Cidr
        testSuite('isValidIpv4Cidr()', 'utils.js', [
            assert(isValidIpv4Cidr('192.168.1.0/24') === true, 'Valid: 192.168.1.0/24', true, isValidIpv4Cidr('192.168.1.0/24')),
            assert(isValidIpv4Cidr('10.0.0.0/8') === true, 'Valid: 10.0.0.0/8', true, isValidIpv4Cidr('10.0.0.0/8')),
            assert(isValidIpv4Cidr('172.16.0.0/16') === true, 'Valid: 172.16.0.0/16', true, isValidIpv4Cidr('172.16.0.0/16')),
            assert(isValidIpv4Cidr('0.0.0.0/0') === true, 'Valid: 0.0.0.0/0 (any)', true, isValidIpv4Cidr('0.0.0.0/0')),
            assert(isValidIpv4Cidr('255.255.255.255/32') === true, 'Valid: 255.255.255.255/32 (host)', true, isValidIpv4Cidr('255.255.255.255/32')),
            assert(isValidIpv4Cidr('192.168.1.0') === false, 'Invalid: Missing CIDR prefix', false, isValidIpv4Cidr('192.168.1.0')),
            assert(isValidIpv4Cidr('192.168.1.0/33') === false, 'Invalid: /33 (out of range)', false, isValidIpv4Cidr('192.168.1.0/33')),
            assert(isValidIpv4Cidr('192.168.1.0/-1') === false, 'Invalid: /-1 (negative)', false, isValidIpv4Cidr('192.168.1.0/-1')),
            assert(isValidIpv4Cidr('256.168.1.0/24') === false, 'Invalid: 256 in octet', false, isValidIpv4Cidr('256.168.1.0/24')),
            assert(isValidIpv4Cidr('192.168/24') === false, 'Invalid: Missing octets', false, isValidIpv4Cidr('192.168/24')),
            assert(isValidIpv4Cidr('') === false, 'Invalid: Empty string', false, isValidIpv4Cidr('')),
            assert(isValidIpv4Cidr(null) === false, 'Invalid: null', false, isValidIpv4Cidr(null))
        ]);
        
        // Test: isValidCidrFormat
        testSuite('isValidCidrFormat()', 'utils.js', [
            assert(isValidCidrFormat('10.0.1.0/24') === true, 'Valid: 10.0.1.0/24', true, isValidCidrFormat('10.0.1.0/24')),
            assert(isValidCidrFormat('192.168.0.0/16') === true, 'Valid: 192.168.0.0/16', true, isValidCidrFormat('192.168.0.0/16')),
            assert(isValidCidrFormat('10.0.1.0') === false, 'Invalid: No prefix', false, isValidCidrFormat('10.0.1.0')),
            assert(isValidCidrFormat('10.0.1/24') === false, 'Invalid: 3 octets only', false, isValidCidrFormat('10.0.1/24')),
            assert(isValidCidrFormat('') === false, 'Invalid: Empty', false, isValidCidrFormat('')),
            assert(isValidCidrFormat(null) === false, 'Invalid: null', false, isValidCidrFormat(null))
        ]);
        
        // Test: escapeHtml
        testSuite('escapeHtml()', 'utils.js', [
            (function() {
                const input = '\x3Cscript\x3Ealert("xss")\x3C/script\x3E';
                const expected = '&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;';
                const result = escapeHtml(input);
                return assert(result === expected, 'Escapes script tags', expected, result);
            })(),
            assert(escapeHtml('Hello & Goodbye') === 'Hello &amp; Goodbye', 
                'Escapes ampersand', 'Hello &amp; Goodbye', escapeHtml('Hello & Goodbye')),
            (function() {
                const input = "'single' \"double\"";
                const expected = '&#39;single&#39; &quot;double&quot;';
                const result = escapeHtml(input);
                return assert(result === expected, 'Escapes quotes', expected, result);
            })(),
            assert(escapeHtml('Normal text') === 'Normal text', 
                'No escaping needed', 'Normal text', escapeHtml('Normal text')),
            assert(escapeHtml('') === '', 'Empty string returns empty', '', escapeHtml(''))
        ]);
        
        // Test: sanitizeInput
        testSuite('sanitizeInput()', 'utils.js', [
            (function() {
                const input = '\x3Cb\x3EBold\x3C/b\x3E';
                const expected = '&lt;b&gt;Bold&lt;/b&gt;';
                const result = sanitizeInput(input, 'html');
                return assert(result === expected, 'HTML sanitization', expected, result);
            })(),
            assert(sanitizeInput('file name.txt', 'filename') === 'file_name.txt', 
                'Filename sanitization', 'file_name.txt', sanitizeInput('file name.txt', 'filename')),
            assert(sanitizeInput('hello world', 'url').includes('hello'), 
                'URL encoding preserves text', true, sanitizeInput('hello world', 'url').includes('hello')),
            assert(sanitizeInput('hello world', 'url') === 'hello%20world', 
                'URL encodes spaces', 'hello%20world', sanitizeInput('hello world', 'url')),
            assert(sanitizeInput('  trimmed  ', 'text').trim() === 'trimmed', 
                'Trims whitespace', 'trimmed', sanitizeInput('  trimmed  ', 'text').trim()),
            assert(sanitizeInput('', 'html') === '', 'Empty returns empty', '', sanitizeInput('', 'html')),
            assert(sanitizeInput(null, 'html') === '', 'Null returns empty', '', sanitizeInput(null, 'html'))
        ]);
        
        // Test: formatNumber
        testSuite('formatNumber()', 'utils.js', [
            assert(formatNumber(1000) === '1,000', 'Formats 1000', '1,000', formatNumber(1000)),
            assert(formatNumber(1000000) === '1,000,000', 'Formats 1000000', '1,000,000', formatNumber(1000000)),
            assert(formatNumber(999) === '999', 'No comma for 999', '999', formatNumber(999)),
            assert(formatNumber(0) === '0', 'Zero returns 0', '0', formatNumber(0)),
            assert(formatNumber(12345678) === '12,345,678', 'Large number', '12,345,678', formatNumber(12345678))
        ]);
        
        // Test: capitalize
        testSuite('capitalize()', 'utils.js', [
            assert(capitalize('hello') === 'Hello', 'Capitalizes hello', 'Hello', capitalize('hello')),
            assert(capitalize('HELLO') === 'HELLO', 'Preserves uppercase', 'HELLO', capitalize('HELLO')),
            assert(capitalize('a') === 'A', 'Single char', 'A', capitalize('a')),
            assert(capitalize('') === '', 'Empty string', '', capitalize('')),
            assert(capitalize(null) === '', 'Null returns empty', '', capitalize(null))
        ]);
        
        // Test: IP Conversion Functions
        testSuite('ipToLong() / longToIp()', 'utils.js', [
            assert(longToIp(ipToLong('192.168.1.1')) === '192.168.1.1', 
                'Round-trip: 192.168.1.1', '192.168.1.1', longToIp(ipToLong('192.168.1.1'))),
            assert(longToIp(ipToLong('10.0.0.1')) === '10.0.0.1', 
                'Round-trip: 10.0.0.1', '10.0.0.1', longToIp(ipToLong('10.0.0.1'))),
            assert(longToIp(ipToLong('255.255.255.255')) === '255.255.255.255', 
                'Round-trip: 255.255.255.255', '255.255.255.255', longToIp(ipToLong('255.255.255.255'))),
            assert(longToIp(ipToLong('0.0.0.0')) === '0.0.0.0', 
                'Round-trip: 0.0.0.0', '0.0.0.0', longToIp(ipToLong('0.0.0.0'))),
            assert(ipToLong('192.168.1.1') === 3232235777, 
                'ipToLong: 192.168.1.1', 3232235777, ipToLong('192.168.1.1')),
            assert(ipToLong('10.0.0.1') === 167772161, 
                'ipToLong: 10.0.0.1', 167772161, ipToLong('10.0.0.1')),
            assert(longToIp(3232235777) === '192.168.1.1', 
                'longToIp: 3232235777', '192.168.1.1', longToIp(3232235777)),
            assert(longToIp(0) === '0.0.0.0', 
                'longToIp: 0', '0.0.0.0', longToIp(0))
        ]);
        
        // Test: ipv4ToInt / intToIpv4
        testSuite('ipv4ToInt() / intToIpv4()', 'utils.js', [
            assert(intToIpv4(ipv4ToInt('192.168.1.1')) === '192.168.1.1', 
                'Round-trip: 192.168.1.1', '192.168.1.1', intToIpv4(ipv4ToInt('192.168.1.1'))),
            assert(ipv4ToInt('0.0.0.0') === 0, 'ipv4ToInt: 0.0.0.0', 0, ipv4ToInt('0.0.0.0')),
            assert(ipv4ToInt('255.255.255.255') === 4294967295, 
                'ipv4ToInt: 255.255.255.255', 4294967295, ipv4ToInt('255.255.255.255')),
            assert(ipv4ToInt('invalid') === null, 'Invalid IP returns null', null, ipv4ToInt('invalid')),
            assert(ipv4ToInt('') === null, 'Empty returns null', null, ipv4ToInt(''))
        ]);
        
        // Test: extractIpFromCidr
        testSuite('extractIpFromCidr()', 'utils.js', [
            assert(extractIpFromCidr('192.168.1.0/24') === '192.168.1.0', 
                'Extract from 192.168.1.0/24', '192.168.1.0', extractIpFromCidr('192.168.1.0/24')),
            assert(extractIpFromCidr('10.0.0.0/8') === '10.0.0.0', 
                'Extract from 10.0.0.0/8', '10.0.0.0', extractIpFromCidr('10.0.0.0/8')),
            assert(extractIpFromCidr('') === '', 'Empty returns empty', '', extractIpFromCidr('')),
            assert(extractIpFromCidr(null) === '', 'Null returns empty', '', extractIpFromCidr(null))
        ]);
        
        // Test: extractPrefixFromCidr
        testSuite('extractPrefixFromCidr()', 'utils.js', [
            assert(extractPrefixFromCidr('192.168.1.0/24') === 24, 
                'Extract /24', 24, extractPrefixFromCidr('192.168.1.0/24')),
            assert(extractPrefixFromCidr('10.0.0.0/8') === 8, 
                'Extract /8', 8, extractPrefixFromCidr('10.0.0.0/8')),
            assert(extractPrefixFromCidr('0.0.0.0/0') === 0, 
                'Extract /0', 0, extractPrefixFromCidr('0.0.0.0/0')),
            assert(extractPrefixFromCidr('192.168.1.0') === null, 
                'No prefix returns null', null, extractPrefixFromCidr('192.168.1.0')),
            assert(extractPrefixFromCidr('') === null, 'Empty returns null', null, extractPrefixFromCidr(''))
        ]);
        
        // Test: prefixToMask
        testSuite('prefixToMask()', 'utils.js', [
            assert(prefixToMask(24) === 4294967040, '/24 mask', 4294967040, prefixToMask(24)),
            assert(prefixToMask(32) === 4294967295, '/32 mask (all ones)', 4294967295, prefixToMask(32)),
            assert(prefixToMask(0) === 0, '/0 mask (all zeros)', 0, prefixToMask(0)),
            assert(prefixToMask(16) === 4294901760, '/16 mask', 4294901760, prefixToMask(16)),
            assert(prefixToMask(33) === null, '/33 invalid', null, prefixToMask(33)),
            assert(prefixToMask(-1) === null, '/-1 invalid', null, prefixToMask(-1))
        ]);
        
        // Test: incrementCidrThirdOctet
        testSuite('incrementCidrThirdOctet()', 'utils.js', [
            assert(incrementCidrThirdOctet('10.0.1.0/24', 1) === '10.0.2.0/24', 
                'Increment 10.0.1.0/24 by 1', '10.0.2.0/24', incrementCidrThirdOctet('10.0.1.0/24', 1)),
            assert(incrementCidrThirdOctet('10.0.1.0/24', 10) === '10.0.11.0/24', 
                'Increment by 10', '10.0.11.0/24', incrementCidrThirdOctet('10.0.1.0/24', 10)),
            assert(incrementCidrThirdOctet('10.0.254.0/24', 1) === '10.0.255.0/24', 
                'Increment to 255', '10.0.255.0/24', incrementCidrThirdOctet('10.0.254.0/24', 1)),
            assert(incrementCidrThirdOctet('10.0.255.0/24', 1) === null, 
                'Overflow returns null', null, incrementCidrThirdOctet('10.0.255.0/24', 1)),
            assert(incrementCidrThirdOctet('invalid', 1) === null, 
                'Invalid CIDR returns null', null, incrementCidrThirdOctet('invalid', 1))
        ]);

        // ========================================================================
        // JS/FORMATTING.JS TESTS
        // ========================================================================
        sectionHeader('üé® js/formatting.js - Display Formatting');
        
        // Test: formatScenario
        testSuite('formatScenario()', 'formatting.js', [
            assert(formatScenario('hyperconverged') === 'Hyperconverged', 
                'Hyperconverged', 'Hyperconverged', formatScenario('hyperconverged')),
            assert(formatScenario('multirack') === 'Multi-Rack', 
                'Multi-Rack', 'Multi-Rack', formatScenario('multirack')),
            assert(formatScenario('disconnected') === 'Disconnected (Air Gapped)', 
                'Disconnected', 'Disconnected (Air Gapped)', formatScenario('disconnected')),
            assert(formatScenario('m365local') === 'M365 Local', 
                'M365 Local', 'M365 Local', formatScenario('m365local')),
            assert(formatScenario('') === '', 'Empty returns empty', '', formatScenario('')),
            assert(formatScenario('custom') === 'Custom', 'Unknown capitalizes', 'Custom', formatScenario('custom'))
        ]);
        
        // Test: formatScale
        testSuite('formatScale()', 'formatting.js', [
            assert(formatScale('low_capacity') === 'Low Capacity', 
                'Low Capacity', 'Low Capacity', formatScale('low_capacity')),
            assert(formatScale('medium') === 'Hyperconverged (1-16 Nodes)', 
                'Medium', 'Hyperconverged (1-16 Nodes)', formatScale('medium')),
            assert(formatScale('rack_aware') === 'Rack Aware (Multi-Room)', 
                'Rack Aware', 'Rack Aware (Multi-Room)', formatScale('rack_aware')),
            assert(formatScale('rack_scale') === 'Rack Scale', 
                'Rack Scale', 'Rack Scale', formatScale('rack_scale'))
        ]);
        
        // Test: formatOutbound
        testSuite('formatOutbound()', 'formatting.js', [
            assert(formatOutbound('public') === 'Public Internet', 
                'Public', 'Public Internet', formatOutbound('public')),
            assert(formatOutbound('private') === 'ExpressRoute / VPN', 
                'Private', 'ExpressRoute / VPN', formatOutbound('private')),
            assert(formatOutbound('air_gapped') === 'Air Gapped', 
                'Air Gapped', 'Air Gapped', formatOutbound('air_gapped')),
            assert(formatOutbound('limited') === 'Limited Connectivity', 
                'Limited', 'Limited Connectivity', formatOutbound('limited'))
        ]);

        // Test: getProxyLabel
        testSuite('getProxyLabel()', 'formatting.js', [
            (function() {
                const origProxy = state.proxy;
                state.proxy = null;
                const result = getProxyLabel();
                state.proxy = origProxy;
                return assert(result === '-', 'No proxy returns dash', '-', result);
            })(),
            (function() {
                const origProxy = state.proxy;
                state.proxy = 'no_proxy';
                const result = getProxyLabel();
                state.proxy = origProxy;
                return assert(result === 'Disabled', 'no_proxy returns Disabled', 'Disabled', result);
            })()
        ]);

        // ========================================================================
        // JS/VALIDATION.JS TESTS
        // ========================================================================
        sectionHeader('‚úÖ js/validation.js - Input Validation');
        
        // Test: validateFieldRealtime (we need to create mock elements)
        testSuite('validateFieldRealtime() - Logic Only', 'validation.js', [
            (function() {
                // Create mock input and feedback element
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                mockInput.parentNode || document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, 'SERVER01', 'netbios');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === true, 'Valid NetBIOS name', true, result);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, '-INVALID', 'netbios');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === false, 'Invalid NetBIOS name', false, result);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, '192.168.1.10/24', 'ipv4cidr');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === true, 'Valid IPv4 CIDR', true, result);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, '192.168.1.1', 'ipv4');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === true, 'Valid IPv4 address', true, result);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, 'contoso.com', 'domain');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === true, 'Valid domain', true, result);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, '100', 'vlan');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === true, 'Valid VLAN (100)', true, result);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                const mockFeedback = document.createElement('div');
                mockFeedback.className = 'validation-feedback';
                document.body.appendChild(mockInput);
                mockInput.parentNode.insertBefore(mockFeedback, mockInput.nextSibling);
                
                const result = validateFieldRealtime(mockInput, '5000', 'vlan');
                mockInput.remove();
                mockFeedback.remove();
                return assert(result === false, 'Invalid VLAN (5000 > 4094)', false, result);
            })()
        ]);

        // ========================================================================
        // JS/DNS.JS TESTS
        // ========================================================================
        sectionHeader('üåê js/dns.js - DNS Server Management');
        
        // Test: DNS Server Array Management
        testSuite('DNS Server Array Management', 'dns.js', [
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['192.168.1.1'];
                addDnsServer();
                const result = state.dnsServers.length === 2;
                state.dnsServers = origServers;
                return assert(result, 'addDnsServer() adds empty entry', 2, state.dnsServers.length);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['192.168.1.1', '192.168.1.2', '192.168.1.3'];
                removeDnsServer(1);
                const result = state.dnsServers.length === 2 && state.dnsServers[1] === '192.168.1.3';
                state.dnsServers = origServers;
                return assert(result, 'removeDnsServer(1) removes middle entry', true, result);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['192.168.1.1'];
                updateDnsServer(0, '  10.0.0.1  ');
                const result = state.dnsServers[0] === '10.0.0.1';
                state.dnsServers = origServers;
                return assert(result, 'updateDnsServer() trims whitespace', '10.0.0.1', state.dnsServers[0]);
            })()
        ]);

        // Test: DNS Validation - Format
        testSuite('DNS Validation - IP Format', 'dns.js', [
            (function() {
                // Test valid IPs don't trigger error
                const origServers = [...state.dnsServers];
                state.dnsServers = ['192.168.1.1', '10.0.0.1'];
                
                // Create mock error/success elements
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = errDiv.classList.contains('hidden');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                return assert(result, 'Valid IPs pass validation', true, result);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['invalid-ip'];
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = !errDiv.classList.contains('hidden');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                return assert(result, 'Invalid IP shows error', true, result);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['256.1.1.1']; // Invalid octet
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = !errDiv.classList.contains('hidden');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                return assert(result, 'IP with invalid octet (256) fails', true, result);
            })()
        ]);

        // Test: DNS Validation - AKS Reserved Subnets
        testSuite('DNS Validation - AKS Reserved Subnets', 'dns.js', [
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['10.96.0.1']; // Within 10.96.0.0/12
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = errDiv.innerText.includes('AKS subnet');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                return assert(result, 'DNS in 10.96.0.0/12 shows AKS error', true, result);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['10.244.1.1']; // Within 10.244.0.0/16
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = errDiv.innerText.includes('AKS subnet');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                return assert(result, 'DNS in 10.244.0.0/16 shows AKS error', true, result);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                state.dnsServers = ['10.95.254.1']; // Just outside 10.96.0.0/12
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = errDiv.classList.contains('hidden');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                return assert(result, 'DNS outside AKS range passes', true, result);
            })()
        ]);

        // Test: DNS Validation - Infrastructure Network Overlap
        testSuite('DNS Validation - Infrastructure Network', 'dns.js', [
            (function() {
                const origServers = [...state.dnsServers];
                const origInfra = state.infra ? { ...state.infra } : null;
                
                state.dnsServers = ['192.168.1.100'];
                state.infra = { start: '192.168.1.1', end: '192.168.1.200' };
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = errDiv.innerText.includes('Infrastructure Network');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                state.infra = origInfra;
                return assert(result, 'DNS in infra range shows error', true, result);
            })(),
            (function() {
                const origServers = [...state.dnsServers];
                const origInfra = state.infra ? { ...state.infra } : null;
                
                state.dnsServers = ['192.168.2.1'];
                state.infra = { start: '192.168.1.1', end: '192.168.1.200' };
                
                const errDiv = document.createElement('div');
                errDiv.id = 'dns-error';
                errDiv.classList.add('hidden');
                const succDiv = document.createElement('div');
                succDiv.id = 'dns-success';
                succDiv.classList.add('hidden');
                document.body.appendChild(errDiv);
                document.body.appendChild(succDiv);
                
                validateAllDnsServers();
                const result = errDiv.classList.contains('hidden');
                
                errDiv.remove();
                succDiv.remove();
                state.dnsServers = origServers;
                state.infra = origInfra;
                return assert(result, 'DNS outside infra range passes', true, result);
            })()
        ]);

        // Test: DNS Service Existing State
        testSuite('DNS Service Existing State', 'dns.js', [
            (function() {
                const origValue = state.dnsServiceExisting;
                updateDnsServiceExisting('yes');
                const result = state.dnsServiceExisting === true;
                state.dnsServiceExisting = origValue;
                return assert(result, 'updateDnsServiceExisting("yes") sets true', true, result);
            })(),
            (function() {
                const origValue = state.dnsServiceExisting;
                updateDnsServiceExisting('no');
                const result = state.dnsServiceExisting === false;
                state.dnsServiceExisting = origValue;
                return assert(result, 'updateDnsServiceExisting("no") sets false', false, result);
            })()
        ]);

        // Test: Local DNS Zone
        testSuite('Local DNS Zone', 'dns.js', [
            (function() {
                // Create mock input element
                const mockInput = document.createElement('input');
                mockInput.id = 'local-dns-zone-input';
                mockInput.value = '  azurelocal.local  ';
                document.body.appendChild(mockInput);
                
                const origValue = state.localDnsZone;
                updateLocalDnsZone();
                const result = state.localDnsZone === 'azurelocal.local';
                
                mockInput.remove();
                state.localDnsZone = origValue;
                return assert(result, 'updateLocalDnsZone() trims value', 'azurelocal.local', state.localDnsZone);
            })(),
            (function() {
                const mockInput = document.createElement('input');
                mockInput.id = 'local-dns-zone-input';
                mockInput.value = '';
                document.body.appendChild(mockInput);
                
                const origValue = state.localDnsZone;
                updateLocalDnsZone();
                const result = state.localDnsZone === null;
                
                mockInput.remove();
                state.localDnsZone = origValue;
                return assert(result, 'Empty input sets null', null, state.localDnsZone);
            })()
        ]);

        // ========================================================================
        // JS/THEME.JS TESTS
        // ========================================================================
        sectionHeader('üé® js/theme.js - Theme Functions');
        
        testSuite('Theme Functions', 'theme.js', [
            (function() {
                const origFontSize = state.fontSize;
                state.fontSize = 'medium';
                increaseFontSize();
                const result = state.fontSize === 'large';
                state.fontSize = origFontSize;
                return assert(result, 'increaseFontSize() medium ‚Üí large', 'large', state.fontSize);
            })(),
            (function() {
                const origFontSize = state.fontSize;
                state.fontSize = 'medium';
                decreaseFontSize();
                const result = state.fontSize === 'small';
                state.fontSize = origFontSize;
                return assert(result, 'decreaseFontSize() medium ‚Üí small', 'small', state.fontSize);
            })(),
            (function() {
                const origFontSize = state.fontSize;
                state.fontSize = 'small'; // minimum
                decreaseFontSize();
                const result = state.fontSize === 'small'; // should not go below small
                state.fontSize = origFontSize;
                return assert(result, 'Font size minimum is small', 'small', state.fontSize);
            })(),
            (function() {
                const origFontSize = state.fontSize;
                state.fontSize = 'x-large'; // maximum
                increaseFontSize();
                const result = state.fontSize === 'x-large'; // should not exceed x-large
                state.fontSize = origFontSize;
                return assert(result, 'Font size maximum is x-large', 'x-large', state.fontSize);
            })()
        ]);

        // ========================================================================
        // EDGE CASES & BOUNDARY TESTS
        // ========================================================================
        sectionHeader('üî¨ Edge Cases & Boundary Tests');
        
        testSuite('Null/Undefined Handling', 'utils.js', [
            assert(escapeHtml(null) === 'null', 'escapeHtml(null)', 'null', escapeHtml(null)),
            assert(escapeHtml(undefined) === 'undefined', 'escapeHtml(undefined)', 'undefined', escapeHtml(undefined)),
            assert(formatNumber(0) === '0', 'formatNumber(0)', '0', formatNumber(0)),
            assert(isValidNetbiosName(0) === false, 'isValidNetbiosName(0)', false, isValidNetbiosName(0))
        ]);
        
        testSuite('IP Address Edge Cases', 'utils.js', [
            assert(ipToLong('0.0.0.1') === 1, 'Min non-zero IP', 1, ipToLong('0.0.0.1')),
            assert(ipToLong('255.255.255.254') === 4294967294, 'Max-1 IP', 4294967294, ipToLong('255.255.255.254')),
            assert(isValidIpv4Cidr('192.168.1.0/0') === true, '/0 is valid', true, isValidIpv4Cidr('192.168.1.0/0')),
            assert(isValidIpv4Cidr('192.168.1.0/32') === true, '/32 is valid', true, isValidIpv4Cidr('192.168.1.0/32'))
        ]);

        // ========================================================================
        // HTML PAGE VALIDATION TESTS
        // ========================================================================
        sectionHeader('üìÑ HTML Page Validation');

        // Note: These tests require HTTP server (e.g., serve.ps1) to work.
        // They will be skipped when running via file:// protocol (e.g., in CI pipeline).
        // The CI pipeline uses html-validate for HTML syntax checking instead.

        // Helper function to fetch and validate HTML pages
        async function validateHtmlPage(pagePath, pageName, requiredElements) {
            try {
                const response = await fetch(pagePath);
                if (!response.ok) {
                    return { success: false, error: `Failed to fetch ${pageName}: ${response.status}` };
                }
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Check for parse errors (malformed HTML)
                const parseError = doc.querySelector('parsererror');
                if (parseError) {
                    return { success: false, error: 'HTML parse error detected' };
                }
                
                // Check for unclosed style tags (common error)
                const styleTagCount = (html.match(/<style/gi) || []).length;
                const styleCloseCount = (html.match(/<\/style>/gi) || []).length;
                if (styleTagCount !== styleCloseCount) {
                    return { success: false, error: `Mismatched style tags: ${styleTagCount} open, ${styleCloseCount} close` };
                }
                
                // Check required elements
                const missing = [];
                for (const selector of requiredElements) {
                    if (!doc.querySelector(selector)) {
                        missing.push(selector);
                    }
                }
                
                if (missing.length > 0) {
                    return { success: false, error: `Missing elements: ${missing.join(', ')}` };
                }
                
                return { success: true, doc: doc };
            } catch (err) {
                return { success: false, error: err.message };
            }
        }

        // Run async HTML validation tests (only when served via HTTP)
        (async function runHtmlValidationTests() {
            // Skip if running via file:// protocol (fetch won't work due to CORS)
            if (window.location.protocol === 'file:') {
                const skipContainer = document.createElement('div');
                skipContainer.className = 'test-suite';
                skipContainer.innerHTML = `
                    <h2>HTML Page Validation <span class="module-badge">Skipped</span></h2>
                    <div class="test-case" style="background: rgba(251, 191, 36, 0.1); border-left: 4px solid #fbbf24;">
                        <span>‚ö†Ô∏è HTML validation tests require HTTP server. Run <code>serve.ps1</code> and open <code>http://localhost:8080/tests/</code> to run these tests locally.</span>
                        <span class="test-status" style="color: #fbbf24;">SKIPPED</span>
                    </div>
                `;
                document.getElementById('test-results').appendChild(skipContainer);
                console.log('HTML validation tests skipped (file:// protocol)');
                return;
            }

            const armResults = [];
            const reportResults = [];
            
            // Test ARM page
            const armValidation = await validateHtmlPage('../arm/arm.html', 'ARM Page', [
                'head', 'body', 'title', '.page-header-bar', '.page-header-logo', '.page-header-logo img', 'main.container'
            ]);
            
            armResults.push(assert(armValidation.success, 'ARM page loads without errors', true, armValidation.success ? true : armValidation.error));
            
            if (armValidation.success) {
                // Check logo image path
                const logoImg = armValidation.doc.querySelector('.page-header-logo img');
                const logoSrc = logoImg ? logoImg.getAttribute('src') : null;
                armResults.push(assert(logoSrc === '../images/odin-logo.png', 'ARM logo path correct', '../images/odin-logo.png', logoSrc));
                
                // Check stylesheet link
                const styleLink = armValidation.doc.querySelector('link[rel="stylesheet"]');
                const styleSrc = styleLink ? styleLink.getAttribute('href') : null;
                armResults.push(assert(styleSrc === '../css/style.css', 'ARM stylesheet path correct', '../css/style.css', styleSrc));
                
                // Check header bar link
                const headerLink = armValidation.doc.querySelector('.page-header-logo');
                const headerHref = headerLink ? headerLink.getAttribute('href') : null;
                armResults.push(assert(headerHref === '../', 'ARM header link correct', '../', headerHref));
            }
            
            testSuite('ARM Page Validation', 'arm/arm.html', armResults);
            
            // Test Report page
            const reportValidation = await validateHtmlPage('../report/report.html', 'Report Page', [
                'head', 'body', 'title', '.page-header-bar', '.page-header-logo', '.page-header-logo img', 'main.container'
            ]);
            
            reportResults.push(assert(reportValidation.success, 'Report page loads without errors', true, reportValidation.success ? true : reportValidation.error));
            
            if (reportValidation.success) {
                // Check logo image path
                const logoImg = reportValidation.doc.querySelector('.page-header-logo img');
                const logoSrc = logoImg ? logoImg.getAttribute('src') : null;
                reportResults.push(assert(logoSrc === '../images/odin-logo.png', 'Report logo path correct', '../images/odin-logo.png', logoSrc));
                
                // Check stylesheet link
                const styleLink = reportValidation.doc.querySelector('link[rel="stylesheet"]');
                const styleSrc = styleLink ? styleLink.getAttribute('href') : null;
                reportResults.push(assert(styleSrc === '../css/style.css', 'Report stylesheet path correct', '../css/style.css', styleSrc));
                
                // Check header bar link
                const headerLink = reportValidation.doc.querySelector('.page-header-logo');
                const headerHref = headerLink ? headerLink.getAttribute('href') : null;
                reportResults.push(assert(headerHref === '../', 'Report header link correct', '../', headerHref));
                
                // Check report has no-print class on header bar
                const headerBar = reportValidation.doc.querySelector('.page-header-bar');
                const hasNoPrint = headerBar ? headerBar.classList.contains('no-print') : false;
                reportResults.push(assert(hasNoPrint, 'Report header bar has no-print class', true, hasNoPrint));
            }
            
            testSuite('Report Page Validation', 'report/report.html', reportResults);
            
            // Update summary after async tests complete
            updateTestSummary();
        })();

        // ========================================================================
        // JS/SCRIPT.JS TESTS - PORT CONFIGURATION VALIDATION
        // ========================================================================
        sectionHeader('üîå js/script.js - Port Configuration Validation');

        // Test: getDuplicateAdapterNameIndices
        testSuite('getDuplicateAdapterNameIndices()', 'script.js', [
            (function() {
                // Save original state
                const origPortConfig = state.portConfig;
                
                // Test: No duplicates with default names
                state.portConfig = [
                    { customName: null, speed: '25GbE', rdma: true },
                    { customName: null, speed: '25GbE', rdma: true }
                ];
                const noDupes = getDuplicateAdapterNameIndices();
                state.portConfig = origPortConfig;
                return assert(noDupes.size === 0, 'No duplicates with default names (Port 1, Port 2)', 0, noDupes.size);
            })(),
            (function() {
                const origPortConfig = state.portConfig;
                
                // Test: Duplicate custom names
                state.portConfig = [
                    { customName: 'Ethernet1', speed: '25GbE', rdma: true },
                    { customName: 'Ethernet1', speed: '25GbE', rdma: true }
                ];
                const dupes = getDuplicateAdapterNameIndices();
                state.portConfig = origPortConfig;
                return assert(dupes.size === 2, 'Detects duplicate custom names', 2, dupes.size);
            })(),
            (function() {
                const origPortConfig = state.portConfig;
                
                // Test: Case-insensitive duplicate detection
                state.portConfig = [
                    { customName: 'Ethernet1', speed: '25GbE', rdma: true },
                    { customName: 'ETHERNET1', speed: '25GbE', rdma: true }
                ];
                const dupes = getDuplicateAdapterNameIndices();
                state.portConfig = origPortConfig;
                return assert(dupes.size === 2, 'Case-insensitive duplicate detection', 2, dupes.size);
            })(),
            (function() {
                const origPortConfig = state.portConfig;
                
                // Test: Mixed unique names
                state.portConfig = [
                    { customName: 'Mgmt1', speed: '25GbE', rdma: false },
                    { customName: 'Storage1', speed: '25GbE', rdma: true },
                    { customName: 'Storage2', speed: '25GbE', rdma: true },
                    { customName: 'Compute1', speed: '25GbE', rdma: false }
                ];
                const dupes = getDuplicateAdapterNameIndices();
                state.portConfig = origPortConfig;
                return assert(dupes.size === 0, 'No duplicates with unique custom names', 0, dupes.size);
            })(),
            (function() {
                const origPortConfig = state.portConfig;
                
                // Test: Three-way duplicate
                state.portConfig = [
                    { customName: 'NIC1', speed: '25GbE', rdma: true },
                    { customName: 'NIC1', speed: '25GbE', rdma: true },
                    { customName: 'NIC1', speed: '25GbE', rdma: true },
                    { customName: 'NIC2', speed: '25GbE', rdma: true }
                ];
                const dupes = getDuplicateAdapterNameIndices();
                state.portConfig = origPortConfig;
                return assert(dupes.size === 3, 'Detects three-way duplicate', 3, dupes.size);
            })(),
            (function() {
                const origPortConfig = state.portConfig;
                
                // Test: Returns correct indices
                state.portConfig = [
                    { customName: 'UniqueA', speed: '25GbE', rdma: true },
                    { customName: 'Duplicate', speed: '25GbE', rdma: true },
                    { customName: 'UniqueB', speed: '25GbE', rdma: true },
                    { customName: 'Duplicate', speed: '25GbE', rdma: true }
                ];
                const dupes = getDuplicateAdapterNameIndices();
                const hasIdx1 = dupes.has(1);
                const hasIdx3 = dupes.has(3);
                const notHasIdx0 = !dupes.has(0);
                const notHasIdx2 = !dupes.has(2);
                state.portConfig = origPortConfig;
                return assert(hasIdx1 && hasIdx3 && notHasIdx0 && notHasIdx2, 
                    'Returns correct duplicate indices (1, 3)', 
                    'indices 1,3', 
                    Array.from(dupes).sort().join(','));
            })()
        ]);

        // ========================================================================
        // JS/SCRIPT.JS TESTS - IMPORT/EXPORT CONFIGURATION
        // ========================================================================
        sectionHeader('üì• js/script.js - Import/Export Configuration');

        // Test: exportConfiguration output structure
        testSuite('exportConfiguration() - Output Structure', 'script.js', [
            (function() {
                // Mock the original state and functions needed
                const mockState = {...state};
                const mockDateNow = Date.now;
                Date.now = () => 1700000000000; // Fixed timestamp for testing
                
                // Create a mock export similar to what exportConfiguration produces
                const exportData = {
                    version: '0.12.0',
                    exportedAt: new Date().toISOString(),
                    state: mockState
                };
                
                Date.now = mockDateNow; // Restore
                
                return assert(
                    exportData.version !== undefined && exportData.exportedAt !== undefined && exportData.state !== undefined,
                    'Export contains version, exportedAt, and state',
                    true,
                    exportData.version !== undefined && exportData.exportedAt !== undefined && exportData.state !== undefined
                );
            })(),
            (function() {
                // Verify state object has all expected fields
                const expectedFields = [
                    'scenario', 'region', 'localInstanceRegion', 'scale', 'nodes', 'witnessType',
                    'theme', 'fontSize', 'ports', 'portConfig', 'storage', 'torSwitchCount',
                    'switchlessLinkMode', 'storagePoolConfiguration', 'rackAwareZones',
                    'intent', 'outbound', 'arc', 'proxy', 'ip', 'infra', 'infraCidr',
                    'infraGateway', 'nodeSettings', 'infraVlan', 'storageAutoIp',
                    'activeDirectory', 'adDomain', 'adOuPath', 'dnsServers', 'localDnsZone',
                    'sdnEnabled', 'sdnFeatures', 'sdnManagement', 'intentOverrides', 'customIntents',
                    'adapterMapping', 'securityConfiguration', 'securitySettings',
                    'privateEndpoints', 'privateEndpointsList'
                ];
                const stateFields = Object.keys(state);
                const missingFields = expectedFields.filter(f => !stateFields.includes(f));
                return assert(
                    missingFields.length === 0,
                    'State object contains all expected wizard fields (' + expectedFields.length + ' fields)',
                    '[]',
                    JSON.stringify(missingFields)
                );
            })()
        ]);

        // Test: parseArmTemplateToState - ARM template detection
        testSuite('parseArmTemplateToState() - ARM Template Detection', 'script.js', [
            (function() {
                // Valid ARM template schema
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result !== null, 'Detects valid ARM template (deploymentTemplate schema)', 'not null', result !== null ? 'object' : 'null');
            })(),
            (function() {
                // Valid ARM parameters file schema
                const armParams = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armParams);
                return assert(result !== null, 'Detects valid ARM parameters file', 'not null', result !== null ? 'object' : 'null');
            })(),
            (function() {
                // Non-ARM JSON (Odin export)
                const odinExport = {
                    "version": "0.12.0",
                    "state": { "scenario": "hyperconverged" }
                };
                const result = parseArmTemplateToState(odinExport);
                return assert(result === null, 'Returns null for non-ARM JSON (Odin export)', 'null', result === null ? 'null' : 'object');
            })(),
            (function() {
                // Invalid schema
                const invalidJson = {
                    "$schema": "https://example.com/invalid-schema.json",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(invalidJson);
                return assert(result === null, 'Returns null for invalid schema', 'null', result === null ? 'null' : 'object');
            })()
        ]);

        // Test: parseArmTemplateToState - Node extraction
        testSuite('parseArmTemplateToState() - Node Count Extraction', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "arcNodeResourceIds": {
                            "value": ["/subscriptions/xxx/node1", "/subscriptions/xxx/node2", "/subscriptions/xxx/node3"]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.nodes === '3', 'Extracts node count from arcNodeResourceIds array', '3', result.nodes);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "physicalNodesSettings": {
                            "value": [
                                { "name": "Node1", "ipv4Address": "10.0.0.1" },
                                { "name": "Node2", "ipv4Address": "10.0.0.2" }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.nodes === '2', 'Extracts node count from physicalNodesSettings array', '2', result.nodes);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "physicalNodesSettings": {
                            "value": [
                                { "name": "Node1", "ipv4Address": "10.0.0.1" },
                                { "name": "Node2", "ipv4Address": "10.0.0.2" }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const hasNodeSettings = result.nodeSettings && result.nodeSettings.length === 2;
                const firstNode = hasNodeSettings ? result.nodeSettings[0] : null;
                return assert(
                    hasNodeSettings && firstNode.name === 'Node1',
                    'Extracts node names from physicalNodesSettings',
                    'Node1',
                    firstNode ? firstNode.name : 'undefined'
                );
            })()
        ]);

        // Test: parseArmTemplateToState - Network settings extraction
        testSuite('parseArmTemplateToState() - Network Settings', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "domainFqdn": { "value": "contoso.local" },
                        "dnsServers": { "value": ["10.0.0.1", "10.0.0.2"] }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.adDomain === 'contoso.local', 'Extracts domain FQDN', 'contoso.local', result.adDomain);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "dnsServers": { "value": ["10.0.0.1", "10.0.0.2"] }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const dnsMatches = result.dnsServers && result.dnsServers.length === 2 && result.dnsServers[0] === '10.0.0.1';
                return assert(dnsMatches, 'Extracts DNS servers array', '["10.0.0.1","10.0.0.2"]', JSON.stringify(result.dnsServers));
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "defaultGateway": { "value": "192.168.1.1" }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.infraGateway === '192.168.1.1', 'Extracts default gateway', '192.168.1.1', result.infraGateway);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "witnessType": { "value": "Cloud" }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.witnessType === 'Cloud', 'Extracts witness type', 'Cloud', result.witnessType);
            })()
        ]);

        // Test: parseArmTemplateToState - Default values for missing ARM fields
        testSuite('parseArmTemplateToState() - Default Values for Missing Fields', 'script.js', [
            (function() {
                // Minimal ARM template - should get defaults
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.region === 'azure_commercial', 'Defaults region to azure_commercial', 'azure_commercial', result.region);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.localInstanceRegion === 'east_us', 'Defaults localInstanceRegion to east_us', 'east_us', result.localInstanceRegion);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.scale === 'medium', 'Defaults scale to medium (hyperconverged)', 'medium', result.scale);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.outbound === 'public', 'Defaults outbound to public', 'public', result.outbound);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {}
                };
                const result = parseArmTemplateToState(armTemplate);
                // Note: ARM imports should prompt for arc/proxy/privateEndpoints via dialog
                // The parseArmTemplateToState sets defaults that may be overridden by dialog
                return assert(result.arc === 'yes' || result.arc === 'no_arc', 'Sets default arc value', 'yes or no_arc', result.arc);
            })()
        ]);

        // Test: parseArmTemplateToState - Storage configuration
        testSuite('parseArmTemplateToState() - Storage Configuration', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "storageConnectivitySwitchless": { "value": true }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.storage === 'switchless', 'Extracts switchless storage from storageConnectivitySwitchless=true', 'switchless', result.storage);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "storageConnectivitySwitchless": { "value": false }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.storage === 'switched', 'Extracts switched storage from storageConnectivitySwitchless=false', 'switched', result.storage);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "enableStorageAutoIp": { "value": true }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.storageAutoIp === 'enabled', 'Extracts storage auto IP enabled', 'enabled', result.storageAutoIp);
            })()
        ]);

        // Test: parseArmTemplateToState - Intent and Port mapping
        testSuite('parseArmTemplateToState() - Intent and Port Mapping', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "networkingPattern": { "value": "convergedManagementCompute" }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.intent === 'mgmt_compute', 'Maps networkingPattern convergedManagementCompute to mgmt_compute', 'mgmt_compute', result.intent);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "networkingPattern": { "value": "hyperConverged" }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.intent === 'all_traffic', 'Maps networkingPattern hyperConverged to all_traffic', 'all_traffic', result.intent);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["NIC1", "NIC2"], "trafficType": ["Management", "Compute"] },
                                { "adapter": ["SMB1", "SMB2"], "trafficType": ["Storage"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                // Should extract 4 total ports (2 NIC + 2 SMB)
                return assert(result.ports === '4', 'Extracts port count from intentList (NIC + SMB adapters)', '4', result.ports);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["Ethernet1", "Ethernet2"], "trafficType": ["Management", "Compute"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                // Should preserve custom adapter names
                const hasCustomName = result.portConfig && result.portConfig[0] && result.portConfig[0].customName === 'Ethernet1';
                return assert(hasCustomName, 'Preserves custom adapter names from intentList', 'Ethernet1', result.portConfig?.[0]?.customName || 'undefined');
            })()
        ]);

        // Test: parseArmTemplateToState - Intent override from intentList traffic types
        testSuite('parseArmTemplateToState() - Intent Override from IntentList', 'script.js', [
            (function() {
                // networkingPattern says hyperConverged but intentList has 2 intents (Mgmt+Compute & Storage)
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "networkingPattern": { "value": "hyperConverged" },
                        "intentList": {
                            "value": [
                                { "name": "HCI", "adapter": ["Port3", "Port2"], "trafficType": ["Management", "Compute"] },
                                { "name": "Storage", "adapter": ["Port0", "Port1"], "trafficType": ["Storage"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.intent === 'mgmt_compute', 'Overrides hyperConverged to mgmt_compute when intentList has Mgmt+Compute & Storage intents', 'mgmt_compute', result.intent);
            })(),
            (function() {
                // networkingPattern says hyperConverged and intentList confirms single all-traffic intent
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "networkingPattern": { "value": "hyperConverged" },
                        "intentList": {
                            "value": [
                                { "name": "HCI", "adapter": ["Port1", "Port2"], "trafficType": ["Management", "Compute", "Storage"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.intent === 'all_traffic', 'Keeps all_traffic when intentList confirms single all-traffic intent', 'all_traffic', result.intent);
            })(),
            (function() {
                // Compute+Storage and Management separate
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["NIC1", "NIC2"], "trafficType": ["Compute", "Storage"] },
                                { "adapter": ["NIC3"], "trafficType": ["Management"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.intent === 'compute_storage', 'Detects compute_storage intent from intentList', 'compute_storage', result.intent);
            })(),
            (function() {
                // 3+ intents should map to custom
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["NIC1"], "trafficType": ["Management"] },
                                { "adapter": ["NIC2"], "trafficType": ["Compute"] },
                                { "adapter": ["NIC3"], "trafficType": ["Storage"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.intent === 'custom', 'Maps 3+ intents to custom', 'custom', result.intent);
            })()
        ]);

        // Test: parseArmTemplateToState - Rack Aware and Local Availability Zones
        testSuite('parseArmTemplateToState() - Rack Aware Import', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "clusterPattern": { "value": "RackAware" },
                        "physicalNodesSettings": {
                            "value": [
                                { "name": "Node1", "ipv4Address": "10.0.0.1" },
                                { "name": "Node2", "ipv4Address": "10.0.0.2" },
                                { "name": "Node3", "ipv4Address": "10.0.0.3" },
                                { "name": "Node4", "ipv4Address": "10.0.0.4" }
                            ]
                        },
                        "localAvailabilityZones": {
                            "value": [
                                { "localAvailabilityZoneName": "Rack-A", "nodes": ["Node1", "Node2"] },
                                { "localAvailabilityZoneName": "Rack-B", "nodes": ["Node3", "Node4"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.scale === 'rack_aware', 'Sets scale to rack_aware for RackAware clusterPattern', 'rack_aware', result.scale);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "clusterPattern": { "value": "RackAware" },
                        "physicalNodesSettings": {
                            "value": [
                                { "name": "Node1", "ipv4Address": "10.0.0.1" },
                                { "name": "Node2", "ipv4Address": "10.0.0.2" },
                                { "name": "Node3", "ipv4Address": "10.0.0.3" },
                                { "name": "Node4", "ipv4Address": "10.0.0.4" }
                            ]
                        },
                        "localAvailabilityZones": {
                            "value": [
                                { "localAvailabilityZoneName": "Rack-A", "nodes": ["Node1", "Node2"] },
                                { "localAvailabilityZoneName": "Rack-B", "nodes": ["Node3", "Node4"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const z = result.rackAwareZones;
                return assert(z && z.zone1Name === 'Rack-A' && z.zone2Name === 'Rack-B', 'Imports zone names from localAvailabilityZones', 'Rack-A / Rack-B', z ? `${z.zone1Name} / ${z.zone2Name}` : 'undefined');
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "clusterPattern": { "value": "RackAware" },
                        "physicalNodesSettings": {
                            "value": [
                                { "name": "Node1", "ipv4Address": "10.0.0.1" },
                                { "name": "Node2", "ipv4Address": "10.0.0.2" },
                                { "name": "Node3", "ipv4Address": "10.0.0.3" },
                                { "name": "Node4", "ipv4Address": "10.0.0.4" }
                            ]
                        },
                        "localAvailabilityZones": {
                            "value": [
                                { "localAvailabilityZoneName": "Rack-A", "nodes": ["Node1", "Node2"] },
                                { "localAvailabilityZoneName": "Rack-B", "nodes": ["Node3", "Node4"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const z = result.rackAwareZones;
                const assignments = z ? z.assignments : {};
                const correct = assignments[1] === 1 && assignments[2] === 1 && assignments[3] === 2 && assignments[4] === 2;
                return assert(correct, 'Maps node assignments to correct zones (Nodes 1-2 ‚Üí Zone1, Nodes 3-4 ‚Üí Zone2)', '{1:1,2:1,3:2,4:2}', JSON.stringify(assignments));
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "clusterPattern": { "value": "RackAware" },
                        "physicalNodesSettings": {
                            "value": [
                                { "name": "Node1", "ipv4Address": "10.0.0.1" },
                                { "name": "Node2", "ipv4Address": "10.0.0.2" }
                            ]
                        },
                        "localAvailabilityZones": {
                            "value": [
                                { "localAvailabilityZoneName": "Zone1", "nodes": ["Node1"] },
                                { "localAvailabilityZoneName": "Zone2", "nodes": ["Node2"] }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.rackAwareZonesConfirmed === true, 'Auto-confirms rack aware zones on import', true, result.rackAwareZonesConfirmed);
            })()
        ]);

        // Test: parseArmTemplateToState - Storage VLAN import from storageNetworkList
        testSuite('parseArmTemplateToState() - Storage VLAN Import', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["NIC1", "NIC2"], "trafficType": ["Management", "Compute"] },
                                { "adapter": ["SMB1", "SMB2"], "trafficType": ["Storage"] }
                            ]
                        },
                        "storageNetworkList": {
                            "value": [
                                { "name": "StorageNetwork1", "networkAdapterName": "SMB1", "vlanId": "21" },
                                { "name": "StorageNetwork2", "networkAdapterName": "SMB2", "vlanId": "22" }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const ov = result.intentOverrides && result.intentOverrides['storage'];
                return assert(ov && ov.storageNetwork1VlanId === 21, 'Imports storage VLAN 1 from storageNetworkList', 21, ov ? ov.storageNetwork1VlanId : 'undefined');
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["NIC1", "NIC2"], "trafficType": ["Management", "Compute"] },
                                { "adapter": ["SMB1", "SMB2"], "trafficType": ["Storage"] }
                            ]
                        },
                        "storageNetworkList": {
                            "value": [
                                { "name": "StorageNetwork1", "networkAdapterName": "SMB1", "vlanId": "21" },
                                { "name": "StorageNetwork2", "networkAdapterName": "SMB2", "vlanId": "22" }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const ov = result.intentOverrides && result.intentOverrides['storage'];
                return assert(ov && ov.storageNetwork2VlanId === 22, 'Imports storage VLAN 2 from storageNetworkList', 22, ov ? ov.storageNetwork2VlanId : 'undefined');
            })(),
            (function() {
                // All-traffic intent should use 'all' override key
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "intentList": {
                            "value": [
                                { "adapter": ["NIC1", "NIC2"], "trafficType": ["Management", "Compute", "Storage"] }
                            ]
                        },
                        "storageNetworkList": {
                            "value": [
                                { "name": "StorageNetwork1", "networkAdapterName": "NIC1", "vlanId": "711" },
                                { "name": "StorageNetwork2", "networkAdapterName": "NIC2", "vlanId": "712" }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const ov = result.intentOverrides && result.intentOverrides['all'];
                return assert(ov && ov.storageNetwork1VlanId === 711, 'Uses all override key for all_traffic intent VLANs', 711, ov ? ov.storageNetwork1VlanId : 'undefined');
            })()
        ]);

        // Test: parseArmTemplateToState - Custom storage subnets import
        testSuite('parseArmTemplateToState() - Custom Storage Subnets Import', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "enableStorageAutoIp": { "value": false },
                        "storageNetworkList": {
                            "value": [
                                {
                                    "name": "StorageNetwork1",
                                    "networkAdapterName": "SMB1",
                                    "vlanId": "21",
                                    "storageAdapterIPInfo": [
                                        { "physicalNode": "Node1", "ipv4Address": "172.25.117.160", "subnetMask": "255.255.255.192" }
                                    ]
                                },
                                {
                                    "name": "StorageNetwork2",
                                    "networkAdapterName": "SMB2",
                                    "vlanId": "22",
                                    "storageAdapterIPInfo": [
                                        { "physicalNode": "Node1", "ipv4Address": "172.25.117.240", "subnetMask": "255.255.255.192" }
                                    ]
                                }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const subnets = result.customStorageSubnets;
                return assert(subnets && subnets.length === 2, 'Imports 2 custom storage subnets from storageNetworkList', 2, subnets ? subnets.length : 0);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "enableStorageAutoIp": { "value": false },
                        "storageNetworkList": {
                            "value": [
                                {
                                    "name": "StorageNetwork1",
                                    "networkAdapterName": "SMB1",
                                    "vlanId": "21",
                                    "storageAdapterIPInfo": [
                                        { "physicalNode": "Node1", "ipv4Address": "172.25.117.160", "subnetMask": "255.255.255.192" }
                                    ]
                                }
                            ]
                        }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const subnets = result.customStorageSubnets;
                // 172.25.117.160 with /26 mask ‚Üí network 172.25.117.128/26
                return assert(subnets && subnets[0] === '172.25.117.128/26', 'Calculates correct CIDR from storage IP and subnet mask', '172.25.117.128/26', subnets ? subnets[0] : 'undefined');
            })()
        ]);

        // Test: parseArmTemplateToState - Security settings
        testSuite('parseArmTemplateToState() - Security Settings', 'script.js', [
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "securityLevel": { "value": "Recommended" }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                return assert(result.securityConfiguration === 'recommended', 'Extracts security level Recommended', 'recommended', result.securityConfiguration);
            })(),
            (function() {
                const armTemplate = {
                    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
                    "parameters": {
                        "bitlockerBootVolume": { "value": false },
                        "bitlockerDataVolumes": { "value": true }
                    }
                };
                const result = parseArmTemplateToState(armTemplate);
                const bootVolume = result.securitySettings && result.securitySettings.bitlockerBootVolume === false;
                const dataVolumes = result.securitySettings && result.securitySettings.bitlockerDataVolumes === true;
                return assert(bootVolume && dataVolumes, 'Extracts individual security settings', 'boot:false, data:true', 
                    `boot:${result.securitySettings?.bitlockerBootVolume}, data:${result.securitySettings?.bitlockerDataVolumes}`);
            })()
        ]);

        // Test: Import handles missing fields gracefully (backward compatibility)
        testSuite('Import Configuration - Backward Compatibility', 'script.js', [
            (function() {
                // Simulate an old export missing new fields like privateEndpoints
                const oldExport = {
                    version: '0.10.0',
                    exportedAt: '2024-01-01T00:00:00Z',
                    state: {
                        scenario: 'hyperconverged',
                        nodes: '3',
                        storage: 'switched'
                        // Missing: privateEndpoints, privateEndpointsList, etc.
                    }
                };
                // Verify the structure is valid even without new fields
                const hasRequiredFields = oldExport.state && oldExport.version;
                return assert(hasRequiredFields, 'Old exports without new fields are valid JSON structure', true, hasRequiredFields);
            })(),
            (function() {
                // Verify current state has all fields that could be missing in old exports
                const newFields = ['privateEndpoints', 'privateEndpointsList', 'rackAwareZones', 'rackAwareTorsPerRoom', 'rackAwareTorArchitecture'];
                const stateHasNewFields = newFields.every(f => f in state);
                return assert(stateHasNewFields, 'Current state defines all new wizard fields', true, stateHasNewFields);
            })()
        ]);

        // Test: State field completeness (ensure new steps automatically included)
        testSuite('State Field Coverage - New Steps Auto-Included', 'script.js', [
            (function() {
                // Critical fields that should be in exports (grouped by wizard step)
                const criticalFields = {
                    // Step 1: Scenario
                    scenario: state.hasOwnProperty('scenario'),
                    // Step 2: Region
                    region: state.hasOwnProperty('region'),
                    localInstanceRegion: state.hasOwnProperty('localInstanceRegion'),
                    // Step 3: Scale
                    scale: state.hasOwnProperty('scale'),
                    // Step 4: Nodes
                    nodes: state.hasOwnProperty('nodes'),
                    // Step 5: Witness
                    witnessType: state.hasOwnProperty('witnessType'),
                    // Networking steps
                    ports: state.hasOwnProperty('ports'),
                    portConfig: state.hasOwnProperty('portConfig'),
                    storage: state.hasOwnProperty('storage'),
                    intent: state.hasOwnProperty('intent'),
                    // Connectivity steps
                    outbound: state.hasOwnProperty('outbound'),
                    arc: state.hasOwnProperty('arc'),
                    proxy: state.hasOwnProperty('proxy'),
                    privateEndpoints: state.hasOwnProperty('privateEndpoints'),
                    // SDN
                    sdnEnabled: state.hasOwnProperty('sdnEnabled'),
                    sdnFeatures: state.hasOwnProperty('sdnFeatures'),
                    // Security
                    securityConfiguration: state.hasOwnProperty('securityConfiguration'),
                    securitySettings: state.hasOwnProperty('securitySettings')
                };
                const missingCritical = Object.entries(criticalFields).filter(([k, v]) => !v).map(([k]) => k);
                return assert(
                    missingCritical.length === 0,
                    'All critical wizard step fields exist in state object',
                    '[]',
                    JSON.stringify(missingCritical)
                );
            })(),
            (function() {
                // Rack-aware fields (newer addition)
                const rackFields = ['rackAwareZones', 'rackAwareTorsPerRoom', 'rackAwareTorArchitecture', 'rackAwareZoneSwapSelection'];
                const hasRackFields = rackFields.every(f => f in state);
                return assert(hasRackFields, 'Rack-aware zone fields exist in state', true, hasRackFields);
            })(),
            (function() {
                // Private endpoint fields (newer addition) 
                const peFields = ['privateEndpoints', 'privateEndpointsList'];
                const hasPeFields = peFields.every(f => f in state);
                return assert(hasPeFields, 'Private endpoint fields exist in state', true, hasPeFields);
            })()
        ]);

        // Test: Detect undocumented state fields (fails when new fields are added without updating this list)
        // PURPOSE: When this test fails, it means a developer added a new field to the state object
        // but hasn't considered import/export functionality. Update the knownFields array below
        // and verify that:
        //   1. exportConfiguration() will include the new field (automatic - exports entire state)
        //   2. importConfiguration() handles missing field gracefully (uses default)
        //   3. parseArmTemplateToState() maps ARM parameter if applicable
        //   4. showArmImportOptionsDialog() prompts user if field isn't in ARM templates
        testSuite('State Field Inventory - Detect Undocumented Fields', 'script.js', [
            (function() {
                // IMPORTANT: When adding new fields to state, add them here and verify import/export handling!
                // This list must match ALL fields in the state object (js/script.js line ~68)
                const knownFields = [
                    // Core wizard state
                    'scenario',
                    'region',
                    'localInstanceRegion',
                    'scale',
                    'nodes',
                    'witnessType',
                    // UI preferences
                    'theme',
                    'fontSize',
                    // Network configuration
                    'ports',
                    'portConfig',
                    'portConfigConfirmed',
                    'storage',
                    'torSwitchCount',
                    'switchlessLinkMode',
                    'storagePoolConfiguration',
                    // Rack-aware zones
                    'rackAwareZones',
                    'rackAwareZonesConfirmed',
                    'rackAwareZoneSwapSelection',
                    'rackAwareTorsPerRoom',
                    'rackAwareTorArchitecture',
                    // Network intents
                    'intent',
                    'customIntentConfirmed',
                    'intentOverrides',
                    'customIntents',
                    'adapterMapping',
                    'adapterMappingConfirmed',
                    'adapterMappingSelection',
                    'overridesConfirmed',
                    // Connectivity
                    'outbound',
                    'arc',
                    'proxy',
                    // IP configuration
                    'ip',
                    'infra',
                    'infraCidr',
                    'infraCidrAuto',
                    'infraGateway',
                    'infraGatewayManual',
                    'nodeSettings',
                    'infraVlan',
                    'infraVlanId',
                    'storageAutoIp',
                    'customStorageSubnets',
                    'customStorageSubnetsConfirmed',
                    // Active Directory
                    'activeDirectory',
                    'adDomain',
                    'adOuPath',
                    'adfsServerName',
                    // DNS
                    'dnsServers',
                    'localDnsZone',
                    'dnsServiceExisting',
                    // SDN
                    'sdnEnabled',
                    'sdnFeatures',
                    'sdnManagement',
                    // Security
                    'securityConfiguration',
                    'securitySettings',
                    'rdmaGuardMessage',
                    // Private endpoints
                    'privateEndpoints',
                    'privateEndpointsList',
                    // Sizer hardware (hidden, imported from Sizer tool)
                    'sizerHardware'
                ];
                
                const actualFields = Object.keys(state);
                const undocumented = actualFields.filter(f => !knownFields.includes(f));
                const extraInList = knownFields.filter(f => !actualFields.includes(f));
                
                // Test for undocumented fields (new fields added to state but not to this list)
                // Failure message includes actionable instructions for the developer
                const failureMsg = undocumented.length > 0 
                    ? 'NEW FIELDS DETECTED: ' + JSON.stringify(undocumented) + 
                      ' -- ACTION REQUIRED: (1) Add field to knownFields array in tests/index.html line ~1455, ' +
                      '(2) Verify importConfiguration handles missing field, ' +
                      '(3) Add ARM mapping in parseArmTemplateToState if applicable, ' +
                      '(4) Add prompt in showArmImportOptionsDialog if not in ARM templates'
                    : '[]';
                
                return assert(
                    undocumented.length === 0,
                    'STATE FIELD INVENTORY: All fields documented for import/export',
                    '[]',
                    failureMsg
                );
            })(),
            (function() {
                // Verify the knownFields list doesn't have stale entries
                const knownFields = [
                    'scenario', 'region', 'localInstanceRegion', 'scale', 'nodes', 'witnessType',
                    'theme', 'fontSize', 'ports', 'portConfig', 'portConfigConfirmed', 'storage',
                    'torSwitchCount', 'switchlessLinkMode', 'storagePoolConfiguration',
                    'rackAwareZones', 'rackAwareZonesConfirmed', 'rackAwareZoneSwapSelection',
                    'rackAwareTorsPerRoom', 'rackAwareTorArchitecture', 'intent', 'customIntentConfirmed',
                    'intentOverrides', 'customIntents', 'adapterMapping', 'adapterMappingConfirmed',
                    'adapterMappingSelection', 'overridesConfirmed', 'outbound', 'arc', 'proxy',
                    'ip', 'infra', 'infraCidr', 'infraCidrAuto', 'infraGateway', 'infraGatewayManual',
                    'nodeSettings', 'infraVlan', 'infraVlanId', 'storageAutoIp', 'customStorageSubnets',
                    'customStorageSubnetsConfirmed', 'activeDirectory', 'adDomain', 'adOuPath',
                    'adfsServerName', 'dnsServers', 'localDnsZone', 'dnsServiceExisting',
                    'sdnEnabled', 'sdnFeatures', 'sdnManagement', 'securityConfiguration',
                    'securitySettings', 'rdmaGuardMessage', 'privateEndpoints', 'privateEndpointsList',
                    'sizerHardware'
                ];
                
                const actualFields = Object.keys(state);
                const staleEntries = knownFields.filter(f => !actualFields.includes(f));
                
                return assert(
                    staleEntries.length === 0,
                    'No stale entries in knownFields (remove fields no longer in state)',
                    '[]',
                    staleEntries.length > 0 ? 'STALE: ' + JSON.stringify(staleEntries) : '[]'
                );
            })()
        ]);

        // ========================================================================
        // REGRESSION TESTS - GitHub Issues #74, #75, #76
        // ========================================================================
        sectionHeader('üêõ Regression Tests - Issues #74, #75, #76');

        // Issue #76: Single-node NIC speed should not be locked at 10 GbE
        testSuite('Issue #76: Single-node NIC speed not locked', 'script.js', [
            (function() {
                // Save original state
                const origNodes = state.nodes;
                const origScale = state.scale;
                const origPortConfig = state.portConfig;

                // Set up single-node standard cluster with existing portConfig at 25GbE
                state.nodes = '1';
                state.scale = 'medium';
                state.portConfig = [
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: null },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: null }
                ];

                // Simulate what the fixed else-branch does: NOT overriding speed
                const pCount = 2;
                const isSingleNode = state.nodes === '1';
                const isLowCapacity = state.scale === 'low_capacity';
                if (isSingleNode && !isLowCapacity) {
                    for (let idx = 0; idx < pCount; idx++) {
                        const pc = state.portConfig[idx];
                        if (!pc) continue;
                        // Speed is NOT overridden (fix for #76)
                        if (!pc.rdmaManual) {
                            pc.rdma = true;
                            pc.rdmaMode = 'RoCEv2';
                        }
                    }
                }

                const speed1 = state.portConfig[0].speed;
                const speed2 = state.portConfig[1].speed;

                // Restore
                state.nodes = origNodes;
                state.scale = origScale;
                state.portConfig = origPortConfig;

                return assert(speed1 === '25GbE' && speed2 === '25GbE',
                    'Single-node: user-selected 25GbE speed preserved (not forced to 10GbE)',
                    '25GbE,25GbE', speed1 + ',' + speed2);
            })()
        ]);

        // Issue #75: VLAN IDs should default to 711/712, not 0
        testSuite('Issue #75: Storage VLAN defaults', 'script.js', [
            (function() {
                // Save original state
                const origOverrides = state.intentOverrides;
                const origIntent = state.intent;
                const origStorage = state.storage;
                const origPorts = state.ports;

                // Test ensureDefaultOverridesForGroups sets 711/712 correctly
                state.intentOverrides = {};
                state.intent = 'all_traffic';
                state.storage = 'switched';
                state.ports = '2';

                const groups = [{ key: 'all', label: 'Group All Traffic', nics: [1, 2] }];
                ensureDefaultOverridesForGroups(groups);

                const v1 = state.intentOverrides['all'].storageNetwork1VlanId;
                const v2 = state.intentOverrides['all'].storageNetwork2VlanId;

                // Restore
                state.intentOverrides = origOverrides;
                state.intent = origIntent;
                state.storage = origStorage;
                state.ports = origPorts;

                return assert(v1 === 711 && v2 === 712,
                    'Default VLAN IDs are 711 and 712 for all_traffic intent',
                    '711,712', v1 + ',' + v2);
            })(),
            (function() {
                // Test that empty string VLAN values are replaced with defaults
                const origOverrides = state.intentOverrides;
                const origStorage = state.storage;
                const origPorts = state.ports;
                const origIntent = state.intent;

                state.intentOverrides = { 'all': { storageNetwork1VlanId: '', storageNetwork2VlanId: '' } };
                state.storage = 'switched';
                state.ports = '2';
                state.intent = 'all_traffic';

                const groups = [{ key: 'all', label: 'Group All Traffic', nics: [1, 2] }];
                ensureDefaultOverridesForGroups(groups);

                const v1 = state.intentOverrides['all'].storageNetwork1VlanId;
                const v2 = state.intentOverrides['all'].storageNetwork2VlanId;

                state.intentOverrides = origOverrides;
                state.storage = origStorage;
                state.ports = origPorts;
                state.intent = origIntent;

                return assert(v1 === 711 && v2 === 712,
                    'Empty string VLAN overrides are replaced with defaults (711/712)',
                    '711,712', v1 + ',' + v2);
            })(),
            (function() {
                // Test that zero VLAN values are replaced with defaults
                const origOverrides = state.intentOverrides;
                const origStorage = state.storage;
                const origPorts = state.ports;
                const origIntent = state.intent;

                state.intentOverrides = { 'storage': { storageNetwork1VlanId: 0, storageNetwork2VlanId: 0 } };
                state.storage = 'switched';
                state.ports = '4';
                state.intent = 'mgmt_compute';

                const groups = [{ key: 'storage', label: 'Storage', nics: [3, 4] }];
                ensureDefaultOverridesForGroups(groups);

                const v1 = state.intentOverrides['storage'].storageNetwork1VlanId;
                const v2 = state.intentOverrides['storage'].storageNetwork2VlanId;

                state.intentOverrides = origOverrides;
                state.storage = origStorage;
                state.ports = origPorts;
                state.intent = origIntent;

                return assert(v1 === 711 && v2 === 712,
                    'Zero VLAN overrides are replaced with defaults (711/712)',
                    '711,712', v1 + ',' + v2);
            })(),
            (function() {
                // Test that valid user-set VLAN values are preserved
                const origOverrides = state.intentOverrides;

                state.intentOverrides = { 'all': { storageNetwork1VlanId: 100, storageNetwork2VlanId: 200 } };

                const groups = [{ key: 'all', label: 'Group All Traffic', nics: [1, 2] }];
                ensureDefaultOverridesForGroups(groups);

                const v1 = state.intentOverrides['all'].storageNetwork1VlanId;
                const v2 = state.intentOverrides['all'].storageNetwork2VlanId;

                state.intentOverrides = origOverrides;

                return assert(v1 === 100 && v2 === 200,
                    'User-set VLAN IDs (100/200) are preserved',
                    '100,200', v1 + ',' + v2);
            })()
        ]);

        // Custom intent + adapter mapping confirmed: VLAN IDs should appear in ARM output
        testSuite('Issue #75: Custom intent VLAN IDs in ARM output', 'script.js', [
            (function() {
                const origState = JSON.parse(JSON.stringify(state));
                const origOpen = window.open;
                window.open = function() {};

                // Set up a 3-node custom intent with adapter mapping confirmed
                state.scenario = 'hyperconverged';
                state.region = 'eastus';
                state.localInstanceRegion = 'East US';
                state.scale = 'medium';
                state.nodes = '3';
                state.ports = '4';
                state.storage = 'switched';
                state.storagePoolConfiguration = 'default';
                state.intent = 'custom';
                state.portConfig = [];
                for (let i = 0; i < 4; i++) {
                    state.portConfig.push({ speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: null });
                }
                state.portConfigConfirmed = true;

                // Custom intent: ports 1-2 = mgmt, 3-4 = storage
                state.customIntents = { 1: 'mgmt', 2: 'mgmt', 3: 'storage', 4: 'storage' };
                state.customIntentConfirmed = true;

                // Adapter mapping confirmed (same as customIntents)
                state.adapterMapping = { 1: 'mgmt', 2: 'mgmt', 3: 'storage', 4: 'storage' };
                state.adapterMappingConfirmed = true;

                // Set VLAN IDs via the override key that adapter mapping path uses (unprefixed 'storage')
                state.intentOverrides = {
                    storage: { storageNetwork1VlanId: 711, storageNetwork2VlanId: 714, rdmaMode: 'RoCEv2', jumboFrames: '1514' },
                    mgmt: { rdmaMode: 'RoCEv2', jumboFrames: '1514' }
                };
                state.overridesConfirmed = true;

                state.storageAutoIp = 'enabled';
                state.nodeSettings = [
                    { name: 'node1', ipCidr: '10.0.0.2/24' },
                    { name: 'node2', ipCidr: '10.0.0.3/24' },
                    { name: 'node3', ipCidr: '10.0.0.4/24' }
                ];
                state.witnessType = 'cloud';
                state.ip = 'static';
                state.infraGateway = '10.0.0.1';
                state.outbound = 'proxy';
                state.proxy = 'none';
                state.arc = 'spn';
                state.infra = { start: '10.0.0.100', end: '10.0.0.200' };
                state.infraCidr = '10.0.0.0/24';
                state.infraVlan = 'default';
                state.activeDirectory = 'azure_ad';
                state.adDomain = 'contoso.local';
                state.dnsServers = ['10.0.0.1'];
                state.privateEndpoints = 'no';
                state.securityConfiguration = 'recommended';
                state.securitySettings = {};
                state.sdnEnabled = 'no';

                try {
                    localStorage.removeItem('azloc_arm_payload');
                    generateArmParameters();
                    const raw = localStorage.getItem('azloc_arm_payload');
                    const payload = raw ? JSON.parse(raw) : null;
                    const arm = payload && payload.parametersFile;
                    let result = 'no_vlans';
                    if (arm && arm.parameters && arm.parameters.storageNetworkList && arm.parameters.storageNetworkList.value) {
                        const nets = arm.parameters.storageNetworkList.value;
                        if (nets.length >= 2) {
                            result = nets[0].vlanId + ',' + nets[1].vlanId;
                        }
                    }

                    Object.assign(state, origState);
                    window.open = origOpen;

                    return assert(result === '711,714',
                        'Custom intent + adapter mapping: VLAN IDs 711/714 in ARM output',
                        '711,714', result);
                } catch (e) {
                    Object.assign(state, origState);
                    window.open = origOpen;
                    return assert(false, 'ARM generation did not throw', 'no error', e.message);
                }
            })()
        ]);

        // Issue #74: StorageNetwork2 adapter name should not duplicate StorageNetwork1
        // Test via generateArmParameters() which stores result in localStorage
        testSuite('Issue #74: Storage adapter names in ARM output', 'script.js', [
            (function() {
                // Save original state and override window.open
                const origState = JSON.parse(JSON.stringify(state));
                const origOpen = window.open;
                window.open = function() {}; // prevent opening new window

                // Set up a fully-ready hyper-converged switched cluster
                state.scenario = 'hyperconverged';
                state.region = 'eastus';
                state.localInstanceRegion = 'East US';
                state.scale = 'medium';
                state.nodes = '2';
                state.ports = '2';
                state.storage = 'switched';
                state.storagePoolConfiguration = 'default';
                state.intent = 'all_traffic';
                state.portConfig = [
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: null },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: null }
                ];
                state.portConfigConfirmed = true;
                state.intentOverrides = {};
                state.adapterMappingConfirmed = false;
                state.adapterMapping = {};
                state.storageAutoIp = 'enabled';
                state.nodeSettings = [
                    { name: 'node1', ipCidr: '10.0.0.2/24' },
                    { name: 'node2', ipCidr: '10.0.0.3/24' }
                ];
                state.witnessType = 'cloud';
                state.ip = 'static';
                state.infraGateway = '10.0.0.1';
                state.outbound = 'proxy';
                state.proxy = 'none';
                state.arc = 'spn';
                state.infra = { start: '10.0.0.100', end: '10.0.0.200' };
                state.infraCidr = '10.0.0.0/24';
                state.infraVlan = 'default';
                state.activeDirectory = 'azure_ad';
                state.adDomain = 'contoso.local';
                state.dnsServers = ['10.0.0.1'];
                state.customIntents = {};
                state.privateEndpoints = 'no';
                state.securityConfiguration = 'recommended';
                state.securitySettings = {};
                state.sdnEnabled = 'no';

                try {
                    localStorage.removeItem('azloc_arm_payload');
                    generateArmParameters();
                    const raw = localStorage.getItem('azloc_arm_payload');
                    const payload = raw ? JSON.parse(raw) : null;
                    const arm = payload && payload.parametersFile;
                    let result = 'no_storage_networks';
                    if (arm && arm.parameters && arm.parameters.storageNetworkList && arm.parameters.storageNetworkList.value) {
                        const storageNetworks = arm.parameters.storageNetworkList.value;
                        if (storageNetworks.length >= 2) {
                            result = storageNetworks[0].networkAdapterName + ',' + storageNetworks[1].networkAdapterName;
                        }
                    }

                    Object.assign(state, origState);
                    window.open = origOpen;

                    return assert(result !== 'Port 1,Port 1' && result !== 'no_storage_networks',
                        'StorageNetwork1 and StorageNetwork2 have distinct adapter names',
                        'Port 1,Port 2', result);
                } catch (e) {
                    Object.assign(state, origState);
                    window.open = origOpen;
                    return assert(false, 'ARM generation did not throw', 'no error', e.message);
                }
            })(),
            (function() {
                // Test custom port names flow through to ARM storage adapter names
                const origState = JSON.parse(JSON.stringify(state));
                const origOpen = window.open;
                window.open = function() {};

                state.scenario = 'hyperconverged';
                state.region = 'eastus';
                state.localInstanceRegion = 'East US';
                state.scale = 'medium';
                state.nodes = '2';
                state.ports = '2';
                state.storage = 'switched';
                state.storagePoolConfiguration = 'default';
                state.intent = 'all_traffic';
                state.portConfig = [
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: 'Mellanox-A' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: 'Mellanox-B' }
                ];
                state.portConfigConfirmed = true;
                state.intentOverrides = {};
                state.adapterMappingConfirmed = false;
                state.adapterMapping = {};
                state.storageAutoIp = 'enabled';
                state.nodeSettings = [
                    { name: 'node1', ipCidr: '10.0.0.2/24' },
                    { name: 'node2', ipCidr: '10.0.0.3/24' }
                ];
                state.witnessType = 'cloud';
                state.ip = 'static';
                state.infraGateway = '10.0.0.1';
                state.outbound = 'proxy';
                state.proxy = 'none';
                state.arc = 'spn';
                state.infra = { start: '10.0.0.100', end: '10.0.0.200' };
                state.infraCidr = '10.0.0.0/24';
                state.infraVlan = 'default';
                state.activeDirectory = 'azure_ad';
                state.adDomain = 'contoso.local';
                state.dnsServers = ['10.0.0.1'];
                state.customIntents = {};
                state.privateEndpoints = 'no';
                state.securityConfiguration = 'recommended';
                state.securitySettings = {};
                state.sdnEnabled = 'no';

                try {
                    localStorage.removeItem('azloc_arm_payload');
                    generateArmParameters();
                    const raw = localStorage.getItem('azloc_arm_payload');
                    const payload = raw ? JSON.parse(raw) : null;
                    const arm = payload && payload.parametersFile;
                    let result = 'no_storage_networks';
                    if (arm && arm.parameters && arm.parameters.storageNetworkList && arm.parameters.storageNetworkList.value) {
                        const storageNetworks = arm.parameters.storageNetworkList.value;
                        if (storageNetworks.length >= 2) {
                            result = storageNetworks[0].networkAdapterName + ',' + storageNetworks[1].networkAdapterName;
                        }
                    }

                    Object.assign(state, origState);
                    window.open = origOpen;

                    return assert(result === 'Mellanox-A,Mellanox-B',
                        'Custom port names (Mellanox-A/B) flow to ARM storage network names',
                        'Mellanox-A,Mellanox-B', result);
                } catch (e) {
                    Object.assign(state, origState);
                    window.open = origOpen;
                    return assert(false, 'ARM generation did not throw', 'no error', e.message);
                }
            })()
        ]);

        // Test switchless storage intent adapter names use Port N (not SMB N)
        testSuite('Issue #74: Switchless storage intent adapter names', 'script.js', [
            (function() {
                const origState = JSON.parse(JSON.stringify(state));
                const origOpen = window.open;
                window.open = function() {};

                // Set up a switchless 4-node cluster with 8 ports (2 mgmt + 6 storage)
                state.scenario = 'hyperconverged';
                state.region = 'eastus';
                state.localInstanceRegion = 'East US';
                state.scale = 'medium';
                state.nodes = '4';
                state.ports = '8';
                state.storage = 'switchless';
                state.storagePoolConfiguration = 'default';
                state.intent = 'mgmt_compute';
                state.portConfig = [];
                for (let i = 0; i < 8; i++) {
                    state.portConfig.push({ speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2', rdmaManual: false, customName: null });
                }
                state.portConfigConfirmed = true;
                state.intentOverrides = {};
                state.adapterMappingConfirmed = false;
                state.adapterMapping = {};
                state.storageAutoIp = 'enabled';
                state.nodeSettings = [
                    { name: 'node1', ipCidr: '10.0.0.2/24' },
                    { name: 'node2', ipCidr: '10.0.0.3/24' },
                    { name: 'node3', ipCidr: '10.0.0.4/24' },
                    { name: 'node4', ipCidr: '10.0.0.5/24' }
                ];
                state.witnessType = 'cloud';
                state.ip = 'static';
                state.infraGateway = '10.0.0.1';
                state.outbound = 'proxy';
                state.proxy = 'none';
                state.arc = 'spn';
                state.infra = { start: '10.0.0.100', end: '10.0.0.200' };
                state.infraCidr = '10.0.0.0/24';
                state.infraVlan = 'default';
                state.activeDirectory = 'azure_ad';
                state.adDomain = 'contoso.local';
                state.dnsServers = ['10.0.0.1'];
                state.customIntents = {};
                state.privateEndpoints = 'no';
                state.securityConfiguration = 'recommended';
                state.securitySettings = {};
                state.sdnEnabled = 'no';

                try {
                    localStorage.removeItem('azloc_arm_payload');
                    generateArmParameters();
                    const raw = localStorage.getItem('azloc_arm_payload');
                    const payload = raw ? JSON.parse(raw) : null;
                    const arm = payload && payload.parametersFile;
                    let result = 'no_intent_list';
                    if (arm && arm.parameters && arm.parameters.intentList && arm.parameters.intentList.value) {
                        const intents = arm.parameters.intentList.value;
                        const storageIntent = intents.find(i => i.trafficType && i.trafficType.includes('Storage'));
                        if (storageIntent && storageIntent.adapter) {
                            result = storageIntent.adapter.join(',');
                        }
                    }

                    Object.assign(state, origState);
                    window.open = origOpen;

                    // Storage adapter names in the intent should use Port N format, not SMB N
                    const hasSMB = result.includes('SMB');
                    return assert(!hasSMB && result !== 'no_intent_list',
                        'Switchless storage intent adapters use Port N names (not SMB N)',
                        'Port 3,Port 4,Port 5,Port 6,Port 7,Port 8', result);
                } catch (e) {
                    Object.assign(state, origState);
                    window.open = origOpen;
                    return assert(false, 'ARM generation did not throw', 'no error', e.message);
                }
            })()
        ]);

        // ========================================================================
        // REGRESSION TESTS - GitHub Issue #78: IP Address Validation
        // ========================================================================
        sectionHeader('üêõ Regression Tests - Issue #78: IP Address Validation');

        // Test isNetworkOrBroadcastAddress utility
        testSuite('Issue #78: isNetworkOrBroadcastAddress utility', 'utils.js', [
            (function() {
                const result = isNetworkOrBroadcastAddress('192.168.1.0', 24);
                return assert(result === 'network',
                    '192.168.1.0/24 is detected as network address',
                    'network', result);
            })(),
            (function() {
                const result = isNetworkOrBroadcastAddress('192.168.1.255', 24);
                return assert(result === 'broadcast',
                    '192.168.1.255/24 is detected as broadcast address',
                    'broadcast', result);
            })(),
            (function() {
                const result = isNetworkOrBroadcastAddress('192.168.1.1', 24);
                return assert(result === null,
                    '192.168.1.1/24 is a valid host address',
                    'null', String(result));
            })(),
            (function() {
                const result = isNetworkOrBroadcastAddress('10.0.0.0', 8);
                return assert(result === 'network',
                    '10.0.0.0/8 is detected as network address',
                    'network', result);
            })(),
            (function() {
                const result = isNetworkOrBroadcastAddress('10.255.255.255', 8);
                return assert(result === 'broadcast',
                    '10.255.255.255/8 is detected as broadcast address',
                    'broadcast', result);
            })(),
            (function() {
                const result = isNetworkOrBroadcastAddress('10.0.0.1', 32);
                return assert(result === null,
                    '/32 host route is always valid',
                    'null', String(result));
            })()
        ]);

        // Test isLastOctetNetworkOrBroadcast utility
        testSuite('Issue #78: isLastOctetNetworkOrBroadcast utility', 'utils.js', [
            (function() {
                const result = isLastOctetNetworkOrBroadcast('192.168.0.0');
                return assert(result === 'network',
                    'Last octet .0 detected as network',
                    'network', result);
            })(),
            (function() {
                const result = isLastOctetNetworkOrBroadcast('192.168.0.255');
                return assert(result === 'broadcast',
                    'Last octet .255 detected as broadcast',
                    'broadcast', result);
            })(),
            (function() {
                const result = isLastOctetNetworkOrBroadcast('192.168.0.1');
                return assert(result === null,
                    'Last octet .1 is valid host',
                    'null', String(result));
            })(),
            (function() {
                const result = isLastOctetNetworkOrBroadcast('10.0.0.254');
                return assert(result === null,
                    'Last octet .254 is valid host',
                    'null', String(result));
            })()
        ]);

        // Test node IP CIDR validation rejects network/broadcast
        testSuite('Issue #78: Node IP rejects network/broadcast', 'script.js', [
            (function() {
                const origNodes = state.nodes;
                const origIp = state.ip;
                const origSettings = state.nodeSettings;

                state.nodes = '1';
                state.ip = 'static';
                state.nodeSettings = [{ name: 'node1', ipCidr: '192.168.1.0/24' }];
                const readiness = getNodeSettingsReadiness();
                const hasNetworkError = readiness.missing.some(m => m.includes('network address'));

                state.nodes = origNodes;
                state.ip = origIp;
                state.nodeSettings = origSettings;

                return assert(hasNetworkError,
                    'Node with .0/24 IP is rejected as network address',
                    'true', String(hasNetworkError));
            })(),
            (function() {
                const origNodes = state.nodes;
                const origIp = state.ip;
                const origSettings = state.nodeSettings;

                state.nodes = '1';
                state.ip = 'static';
                state.nodeSettings = [{ name: 'node1', ipCidr: '192.168.1.255/24' }];
                const readiness = getNodeSettingsReadiness();
                const hasBroadcastError = readiness.missing.some(m => m.includes('broadcast address'));

                state.nodes = origNodes;
                state.ip = origIp;
                state.nodeSettings = origSettings;

                return assert(hasBroadcastError,
                    'Node with .255/24 IP is rejected as broadcast address',
                    'true', String(hasBroadcastError));
            })(),
            (function() {
                const origNodes = state.nodes;
                const origIp = state.ip;
                const origSettings = state.nodeSettings;

                state.nodes = '1';
                state.ip = 'static';
                state.nodeSettings = [{ name: 'node1', ipCidr: '192.168.1.10/24' }];
                const readiness = getNodeSettingsReadiness();

                state.nodes = origNodes;
                state.ip = origIp;
                state.nodeSettings = origSettings;

                return assert(readiness.ready === true,
                    'Node with .10/24 IP is accepted as valid host',
                    'true', String(readiness.ready));
            })()
        ]);

        // ========================================================================
        // REGRESSION TESTS - GitHub Issue #88: NIC Mapping to Intent
        // ========================================================================
        sectionHeader('üêõ Regression Tests - Issue #88: NIC Mapping to Intent');

        // Test: getMgmtComputeNicAssignment prefers non-RDMA ports for Mgmt+Compute on Low Capacity
        testSuite('Issue #88: getMgmtComputeNicAssignment respects RDMA on Low Capacity', 'script.js', [
            (function() {
                // Setup: Low Capacity, 4 ports, ports 3&4 are RDMA, ports 1&2 are non-RDMA
                const origScale = state.scale;
                const origPorts = state.ports;
                const origPortConfig = state.portConfig;

                state.scale = 'low_capacity';
                state.ports = '4';
                state.portConfig = [
                    { speed: '1GbE', rdma: false, rdmaMode: 'Disabled' },
                    { speed: '1GbE', rdma: false, rdmaMode: 'Disabled' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' }
                ];

                const result = getMgmtComputeNicAssignment(4);

                state.scale = origScale;
                state.ports = origPorts;
                state.portConfig = origPortConfig;

                const mgmtOk = JSON.stringify(result.mgmtCompute) === JSON.stringify([1, 2]);
                const storageOk = JSON.stringify(result.storage) === JSON.stringify([3, 4]);
                return assert(mgmtOk && storageOk,
                    'Non-RDMA ports (1,2) assigned to Mgmt+Compute, RDMA ports (3,4) to Storage',
                    'mgmt:[1,2] storage:[3,4]',
                    'mgmt:[' + result.mgmtCompute + '] storage:[' + result.storage + ']');
            })(),
            (function() {
                // Setup: Low Capacity, 4 ports, ports 1&2 are RDMA, ports 3&4 are non-RDMA
                const origScale = state.scale;
                const origPorts = state.ports;
                const origPortConfig = state.portConfig;

                state.scale = 'low_capacity';
                state.ports = '4';
                state.portConfig = [
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '1GbE', rdma: false, rdmaMode: 'Disabled' },
                    { speed: '1GbE', rdma: false, rdmaMode: 'Disabled' }
                ];

                const result = getMgmtComputeNicAssignment(4);

                state.scale = origScale;
                state.ports = origPorts;
                state.portConfig = origPortConfig;

                const mgmtOk = JSON.stringify(result.mgmtCompute) === JSON.stringify([3, 4]);
                const storageOk = JSON.stringify(result.storage) === JSON.stringify([1, 2]);
                return assert(mgmtOk && storageOk,
                    'RDMA ports (1,2) go to Storage when non-RDMA ports (3,4) available for Mgmt+Compute',
                    'mgmt:[3,4] storage:[1,2]',
                    'mgmt:[' + result.mgmtCompute + '] storage:[' + result.storage + ']');
            })(),
            (function() {
                // Setup: Low Capacity, 4 ports, all RDMA ‚Äî should fallback to [1,2] Mgmt
                const origScale = state.scale;
                const origPorts = state.ports;
                const origPortConfig = state.portConfig;

                state.scale = 'low_capacity';
                state.ports = '4';
                state.portConfig = [
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' }
                ];

                const result = getMgmtComputeNicAssignment(4);

                state.scale = origScale;
                state.ports = origPorts;
                state.portConfig = origPortConfig;

                const mgmtOk = JSON.stringify(result.mgmtCompute) === JSON.stringify([1, 2]);
                const storageOk = JSON.stringify(result.storage) === JSON.stringify([3, 4]);
                return assert(mgmtOk && storageOk && result.allRdma === true,
                    'All-RDMA config: ports 1,2 to Mgmt+Compute, ports 3,4 to Storage',
                    'mgmt:[1,2] storage:[3,4] allRdma:true',
                    'mgmt:[' + result.mgmtCompute + '] storage:[' + result.storage + '] allRdma:' + result.allRdma);
            })()
        ]);

        // Test: getIntentNicGroups matches getDefaultAdapterMapping for Low Capacity mgmt_compute
        testSuite('Issue #88: NIC groups consistent with adapter mapping defaults', 'script.js', [
            (function() {
                // Verify getIntentNicGroups and getDefaultAdapterMapping produce consistent
                // port assignments for mgmt_compute intent on Low Capacity.
                const origScale = state.scale;
                const origPorts = state.ports;
                const origPortConfig = state.portConfig;
                const origIntent = state.intent;
                const origMapping = state.adapterMapping;
                const origConfirmed = state.adapterMappingConfirmed;

                state.scale = 'low_capacity';
                state.ports = '4';
                state.intent = 'mgmt_compute';
                state.portConfig = [
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '25GbE', rdma: true, rdmaMode: 'RoCEv2' },
                    { speed: '1GbE', rdma: false, rdmaMode: 'Disabled' },
                    { speed: '1GbE', rdma: false, rdmaMode: 'Disabled' }
                ];
                state.adapterMapping = {};
                state.adapterMappingConfirmed = false;

                // getIntentNicGroups fallback (no confirmed mapping)
                const nicGroups = getIntentNicGroups('mgmt_compute', 4);
                const mgmtGroup = nicGroups.find(g => g.key === 'mgmt_compute');
                const storageGroup = nicGroups.find(g => g.key === 'storage');

                // getDefaultAdapterMapping
                const defaultMapping = getDefaultAdapterMapping('mgmt_compute', 4);
                const defaultMgmt = [];
                const defaultStorage = [];
                for (let i = 1; i <= 4; i++) {
                    if (defaultMapping[i] === 'mgmt_compute') defaultMgmt.push(i);
                    if (defaultMapping[i] === 'storage') defaultStorage.push(i);
                }

                state.scale = origScale;
                state.ports = origPorts;
                state.portConfig = origPortConfig;
                state.intent = origIntent;
                state.adapterMapping = origMapping;
                state.adapterMappingConfirmed = origConfirmed;

                const groupMgmt = mgmtGroup ? JSON.stringify(mgmtGroup.nics) : '[]';
                const groupStorage = storageGroup ? JSON.stringify(storageGroup.nics) : '[]';
                const mapMgmt = JSON.stringify(defaultMgmt);
                const mapStorage = JSON.stringify(defaultStorage);

                const consistent = groupMgmt === mapMgmt && groupStorage === mapStorage;
                return assert(consistent,
                    'NIC groups and default adapter mapping agree on port assignments',
                    'groups:' + mapMgmt + '/' + mapStorage,
                    'groups:' + groupMgmt + '/' + groupStorage);
            })()
        ]);

        // ========================================================================
        // SIZER/SIZER.JS TESTS
        // ========================================================================
        sectionHeader('üßÆ sizer/sizer.js - Sizer Calculations');

        // --- Constants Validation ---
        testSuite('CPU_GENERATIONS', 'sizer.js', [
            assert(CPU_GENERATIONS.intel.length >= 3, 'Intel has at least 3 CPU generations', '>=3', CPU_GENERATIONS.intel.length),
            assert(CPU_GENERATIONS.amd.length >= 4, 'AMD has at least 4 CPU generations', '>=4', CPU_GENERATIONS.amd.length),
            assert(CPU_GENERATIONS.intel[0].coreOptions.length > 0, 'Intel gen has core options', '>0', CPU_GENERATIONS.intel[0].coreOptions.length),
            assert(CPU_GENERATIONS.amd[0].coreOptions.length > 0, 'AMD gen has core options', '>0', CPU_GENERATIONS.amd[0].coreOptions.length),
            assert(CPU_GENERATIONS.intel.every(g => g.id && g.name && g.defaultCores), 'All Intel gens have id, name, defaultCores', true,
                CPU_GENERATIONS.intel.every(g => g.id && g.name && g.defaultCores)),
            assert(CPU_GENERATIONS.amd.every(g => g.id && g.name && g.defaultCores), 'All AMD gens have id, name, defaultCores', true,
                CPU_GENERATIONS.amd.every(g => g.id && g.name && g.defaultCores))
        ]);

        testSuite('RESILIENCY_CONFIG', 'sizer.js', [
            assert(RESILIENCY_CONFIG['simple'].multiplier === 1, 'Simple: multiplier = 1', 1, RESILIENCY_CONFIG['simple'].multiplier),
            assert(RESILIENCY_CONFIG['2way'].multiplier === 2, '2-way: multiplier = 2', 2, RESILIENCY_CONFIG['2way'].multiplier),
            assert(RESILIENCY_CONFIG['3way'].multiplier === 3, '3-way: multiplier = 3', 3, RESILIENCY_CONFIG['3way'].multiplier),
            assert(RESILIENCY_CONFIG['4way'].multiplier === 4, '4-way: multiplier = 4', 4, RESILIENCY_CONFIG['4way'].multiplier),
            assert(RESILIENCY_CONFIG['4way'].minNodes === 4, '4-way: minNodes = 4', 4, RESILIENCY_CONFIG['4way'].minNodes),
            assert(RESILIENCY_CONFIG['4way'].multiplier === 4, '4-way CONFIG.multiplier = 4 (consolidated)', 4, RESILIENCY_CONFIG['4way'].multiplier),
            assert(RESILIENCY_CONFIG['3way'].minNodes === 3, '3-way: minNodes = 3', 3, RESILIENCY_CONFIG['3way'].minNodes)
        ]);

        testSuite('AVD_PROFILES', 'sizer.js', [
            assert(AVD_PROFILES.light.multi.vcpusPerUser === 0.5, 'Light multi: 0.5 vCPUs/user', 0.5, AVD_PROFILES.light.multi.vcpusPerUser),
            assert(AVD_PROFILES.medium.multi.vcpusPerUser === 1, 'Medium multi: 1 vCPU/user', 1, AVD_PROFILES.medium.multi.vcpusPerUser),
            assert(AVD_PROFILES.heavy.multi.vcpusPerUser === 1.5, 'Heavy multi: 1.5 vCPUs/user', 1.5, AVD_PROFILES.heavy.multi.vcpusPerUser),
            assert(AVD_PROFILES.power.multi.vcpusPerUser === 2, 'Power multi: 2 vCPUs/user', 2, AVD_PROFILES.power.multi.vcpusPerUser),
            assert(AVD_PROFILES.light.single.vcpusPerUser === 2, 'Light single: 2 vCPUs/user', 2, AVD_PROFILES.light.single.vcpusPerUser),
            assert(AVD_PROFILES.medium.single.vcpusPerUser === 4, 'Medium single: 4 vCPUs/user', 4, AVD_PROFILES.medium.single.vcpusPerUser),
            assert(AVD_PROFILES.custom !== undefined, 'Custom profile exists', true, AVD_PROFILES.custom !== undefined),
            assert(AVD_PROFILES.custom.name === 'Custom', 'Custom profile name is Custom', 'Custom', AVD_PROFILES.custom.name),
            assert(AVD_PROFILES.light.multi.memoryPerUser < AVD_PROFILES.medium.multi.memoryPerUser, 'Light memory < Medium memory', true,
                AVD_PROFILES.light.multi.memoryPerUser < AVD_PROFILES.medium.multi.memoryPerUser),
            assert(AVD_PROFILES.medium.multi.memoryPerUser < AVD_PROFILES.power.multi.memoryPerUser, 'Medium memory < Power memory', true,
                AVD_PROFILES.medium.multi.memoryPerUser < AVD_PROFILES.power.multi.memoryPerUser),
            assert(AVD_PROFILES.light.maxUsersPerVcpu === 6, 'Light: 6 users/vCPU max density', 6, AVD_PROFILES.light.maxUsersPerVcpu),
            assert(AVD_PROFILES.medium.maxUsersPerVcpu === 4, 'Medium: 4 users/vCPU max density', 4, AVD_PROFILES.medium.maxUsersPerVcpu),
            assert(AVD_PROFILES.heavy !== undefined, 'Heavy profile exists', true, AVD_PROFILES.heavy !== undefined)
        ]);

        testSuite('STORAGE_TIERING_OPTIONS', 'sizer.js', [
            assert(STORAGE_TIERING_OPTIONS['all-flash'].length >= 2, 'All-flash has at least 2 options', '>=2', STORAGE_TIERING_OPTIONS['all-flash'].length),
            assert(STORAGE_TIERING_OPTIONS['mixed-flash'].length >= 1, 'Mixed-flash has at least 1 option', '>=1', STORAGE_TIERING_OPTIONS['mixed-flash'].length),
            assert(STORAGE_TIERING_OPTIONS['hybrid'].length >= 2, 'Hybrid has at least 2 options', '>=2', STORAGE_TIERING_OPTIONS['hybrid'].length),
            assert(STORAGE_TIERING_OPTIONS['all-flash'][0].isTiered === false, 'All-flash is not tiered', false, STORAGE_TIERING_OPTIONS['all-flash'][0].isTiered),
            assert(STORAGE_TIERING_OPTIONS['mixed-flash'][0].isTiered === true, 'Mixed-flash is tiered', true, STORAGE_TIERING_OPTIONS['mixed-flash'][0].isTiered)
        ]);

        // --- formatDiskSize() ---
        testSuite('formatDiskSize()', 'sizer.js', [
            assert(formatDiskSize(100) === '100 GB', 'Format 100 GB', '100 GB', formatDiskSize(100)),
            assert(formatDiskSize(512) === '512 GB', 'Format 512 GB', '512 GB', formatDiskSize(512)),
            assert(formatDiskSize(1024) === '1.0 TB', 'Format 1024 GB = 1.0 TB', '1.0 TB', formatDiskSize(1024)),
            assert(formatDiskSize(3584) === '3.5 TB', 'Format 3584 GB = 3.5 TB', '3.5 TB', formatDiskSize(3584)),
            assert(formatDiskSize(2048) === '2.0 TB', 'Format 2048 GB = 2.0 TB', '2.0 TB', formatDiskSize(2048))
        ]);

        // --- escapeHtmlSizer() ---
        testSuite('escapeHtmlSizer()', 'sizer.js', [
            assert(escapeHtmlSizer('hello') === 'hello', 'Plain text unchanged', 'hello', escapeHtmlSizer('hello')),
            assert(escapeHtmlSizer('<script>') === '&lt;script&gt;', 'Escapes angle brackets', '&lt;script&gt;', escapeHtmlSizer('<script>')),
            assert(escapeHtmlSizer('a & b') === 'a &amp; b', 'Escapes ampersand', 'a &amp; b', escapeHtmlSizer('a & b')),
            assert(escapeHtmlSizer('"quoted"') === '&quot;quoted&quot;', 'Escapes double quotes', '&quot;quoted&quot;', escapeHtmlSizer('"quoted"')),
            assert(escapeHtmlSizer('') === '', 'Empty string returns empty', '', escapeHtmlSizer('')),
            assert(escapeHtmlSizer(null) === '', 'Null returns empty', '', escapeHtmlSizer(null)),
            assert(escapeHtmlSizer(undefined) === '', 'Undefined returns empty', '', escapeHtmlSizer(undefined))
        ]);

        // --- getWorkloadTypeName() ---
        testSuite('getWorkloadTypeName()', 'sizer.js', [
            assert(getWorkloadTypeName('vm') === 'VMs', 'VM type name', 'VMs', getWorkloadTypeName('vm')),
            assert(getWorkloadTypeName('aks') === 'AKS Arc', 'AKS type name', 'AKS Arc', getWorkloadTypeName('aks')),
            assert(getWorkloadTypeName('avd') === 'AVD', 'AVD type name', 'AVD', getWorkloadTypeName('avd')),
            assert(getWorkloadTypeName('unknown') === '', 'Unknown type returns empty', '', getWorkloadTypeName('unknown'))
        ]);

        // --- mapSizerToDesignerScale() ---
        testSuite('mapSizerToDesignerScale()', 'sizer.js', [
            assert(mapSizerToDesignerScale('rack-aware') === 'rack_aware', 'rack-aware ‚Üí rack_aware', 'rack_aware', mapSizerToDesignerScale('rack-aware')),
            assert(mapSizerToDesignerScale('standard') === 'medium', 'standard ‚Üí medium', 'medium', mapSizerToDesignerScale('standard')),
            assert(mapSizerToDesignerScale('single') === 'medium', 'single ‚Üí medium', 'medium', mapSizerToDesignerScale('single'))
        ]);

        // --- calculateWorkloadRequirements() ---
        testSuite('calculateWorkloadRequirements() - VM', 'sizer.js', [
            (() => {
                const w = { type: 'vm', vcpus: 4, memory: 16, storage: 100, count: 10 };
                const r = calculateWorkloadRequirements(w);
                return assert(r.vcpus === 40, 'VM: 10 √ó 4 vCPUs = 40', 40, r.vcpus);
            })(),
            (() => {
                const w = { type: 'vm', vcpus: 4, memory: 16, storage: 100, count: 10 };
                const r = calculateWorkloadRequirements(w);
                return assert(r.memory === 160, 'VM: 10 √ó 16 GB = 160 GB', 160, r.memory);
            })(),
            (() => {
                const w = { type: 'vm', vcpus: 4, memory: 16, storage: 100, count: 10 };
                const r = calculateWorkloadRequirements(w);
                return assert(r.storage === 1000, 'VM: 10 √ó 100 GB = 1000 GB', 1000, r.storage);
            })(),
            (() => {
                const w = { type: 'vm', vcpus: 8, memory: 32, storage: 256, count: 1 };
                const r = calculateWorkloadRequirements(w);
                return assert(r.vcpus === 8 && r.memory === 32 && r.storage === 256,
                    'VM: single VM preserves values', '8/32/256', r.vcpus + '/' + r.memory + '/' + r.storage);
            })()
        ]);

        testSuite('calculateWorkloadRequirements() - AKS', 'sizer.js', [
            (() => {
                const w = {
                    type: 'aks', clusterCount: 1,
                    controlPlaneNodes: 3, controlPlaneVcpus: 4, controlPlaneMemory: 8,
                    workerNodes: 3, workerVcpus: 8, workerMemory: 16, workerStorage: 200
                };
                const r = calculateWorkloadRequirements(w);
                // CP: 3√ó4=12, Worker: 3√ó8=24, total vCPUs = 36
                return assert(r.vcpus === 36, 'AKS: 1 cluster vCPUs = 36', 36, r.vcpus);
            })(),
            (() => {
                const w = {
                    type: 'aks', clusterCount: 2,
                    controlPlaneNodes: 3, controlPlaneVcpus: 4, controlPlaneMemory: 8,
                    workerNodes: 3, workerVcpus: 8, workerMemory: 16, workerStorage: 200
                };
                const r = calculateWorkloadRequirements(w);
                // (12+24)*2 = 72
                return assert(r.vcpus === 72, 'AKS: 2 clusters doubles vCPUs', 72, r.vcpus);
            })(),
            (() => {
                const w = {
                    type: 'aks', clusterCount: 1,
                    controlPlaneNodes: 3, controlPlaneVcpus: 4, controlPlaneMemory: 8,
                    workerNodes: 3, workerVcpus: 8, workerMemory: 16, workerStorage: 200
                };
                const r = calculateWorkloadRequirements(w);
                // CP mem: 3√ó8=24, Worker mem: 3√ó16=48, total = 72
                return assert(r.memory === 72, 'AKS: 1 cluster memory = 72 GB', 72, r.memory);
            })(),
            (() => {
                const w = {
                    type: 'aks', clusterCount: 1,
                    controlPlaneNodes: 3, controlPlaneVcpus: 4, controlPlaneMemory: 8,
                    workerNodes: 3, workerVcpus: 8, workerMemory: 16, workerStorage: 200
                };
                const r = calculateWorkloadRequirements(w);
                // CP storage: 3√ó100=300, Worker storage: 3√ó200=600, total = 900
                return assert(r.storage === 900, 'AKS: 1 cluster storage = 900 GB', 900, r.storage);
            })()
        ]);

        testSuite('calculateWorkloadRequirements() - AVD', 'sizer.js', [
            (() => {
                const w = { type: 'avd', profile: 'light', userCount: 100 };
                const r = calculateWorkloadRequirements(w);
                // 0.5 vCPUs √ó 100 = 50
                return assert(r.vcpus === 50, 'AVD Light: 100 users = 50 vCPUs', 50, r.vcpus);
            })(),
            (() => {
                const w = { type: 'avd', profile: 'medium', userCount: 50 };
                const r = calculateWorkloadRequirements(w);
                // 1 vCPU √ó 50 = 50, 4GB √ó 50 = 200, 40GB √ó 50 = 2000
                return assert(r.vcpus === 50 && r.memory === 200 && r.storage === 2000,
                    'AVD Medium: 50 users = 50/200/2000', '50/200/2000', r.vcpus + '/' + r.memory + '/' + r.storage);
            })(),
            (() => {
                const w = { type: 'avd', profile: 'power', userCount: 25 };
                const r = calculateWorkloadRequirements(w);
                // 2 vCPUs √ó 25 = 50, 8GB √ó 25 = 200, 80GB √ó 25 = 2000
                return assert(r.vcpus === 50 && r.memory === 200 && r.storage === 2000,
                    'AVD Power: 25 users = 50/200/2000', '50/200/2000', r.vcpus + '/' + r.memory + '/' + r.storage);
            })(),
            (() => {
                const w = { type: 'avd', profile: 'custom', userCount: 10, customVcpus: 4, customMemory: 16, customStorage: 100 };
                const r = calculateWorkloadRequirements(w);
                // 4 vCPUs √ó 10 = 40, 16GB √ó 10 = 160, 100GB √ó 10 = 1000
                return assert(r.vcpus === 40 && r.memory === 160 && r.storage === 1000,
                    'AVD Custom: 10 users √ó 4/16/100 = 40/160/1000', '40/160/1000', r.vcpus + '/' + r.memory + '/' + r.storage);
            })()
        ]);

        // --- getRecommendedNodeCount() ---
        testSuite('getRecommendedNodeCount()', 'sizer.js', [
            (() => {
                // Small workload, 24 cores √ó 2 sockets, 512 GB memory, 4 √ó 3.5TB disks
                const hw = {
                    totalPhysicalCores: 48,
                    memoryGB: 512,
                    diskConfig: { isTiered: false, capacity: { count: 4, sizeGB: 3584, type: 'NVMe' } }
                };
                const r = getRecommendedNodeCount(40, 160, 1000, hw, 2, '2way');
                return assert(r.recommended >= 1, 'Small workload recommends at least 1 node', '>=1', r.recommended);
            })(),
            (() => {
                // Verify bottleneck detection - compute heavy
                const hw = {
                    totalPhysicalCores: 8,  // small cores
                    memoryGB: 2048,         // huge memory
                    diskConfig: { isTiered: false, capacity: { count: 24, sizeGB: 3584, type: 'NVMe' } }
                };
                const r = getRecommendedNodeCount(400, 100, 100, hw, 2, '2way');
                return assert(r.bottleneck === 'compute', 'Compute-heavy workload identifies compute bottleneck', 'compute', r.bottleneck);
            })(),
            (() => {
                // Verify bottleneck detection - memory heavy
                const hw = {
                    totalPhysicalCores: 128,
                    memoryGB: 128,  // small memory, - 32 overhead = 96 usable
                    diskConfig: { isTiered: false, capacity: { count: 24, sizeGB: 3584, type: 'NVMe' } }
                };
                const r = getRecommendedNodeCount(10, 500, 100, hw, 2, '2way');
                return assert(r.bottleneck === 'memory', 'Memory-heavy workload identifies memory bottleneck', 'memory', r.bottleneck);
            })(),
            (() => {
                // Verify bottleneck detection - storage heavy
                const hw = {
                    totalPhysicalCores: 128,
                    memoryGB: 2048,
                    diskConfig: { isTiered: false, capacity: { count: 1, sizeGB: 100, type: 'SSD' } }
                };
                const r = getRecommendedNodeCount(10, 100, 50000, hw, 3, '3way');
                return assert(r.bottleneck === 'storage', 'Storage-heavy workload identifies storage bottleneck', 'storage', r.bottleneck);
            })(),
            (() => {
                // 3-way mirror enforces minNodes=3
                const hw = {
                    totalPhysicalCores: 128,
                    memoryGB: 2048,
                    diskConfig: { isTiered: false, capacity: { count: 24, sizeGB: 3584, type: 'NVMe' } }
                };
                const r = getRecommendedNodeCount(10, 10, 10, hw, 3, '3way');
                return assert(r.recommended >= 3, '3-way mirror: enforces minimum 3 nodes', '>=3', r.recommended);
            })(),
            (() => {
                // Return structure has all expected fields
                const hw = {
                    totalPhysicalCores: 48,
                    memoryGB: 512,
                    diskConfig: { isTiered: false, capacity: { count: 4, sizeGB: 3584, type: 'NVMe' } }
                };
                const r = getRecommendedNodeCount(40, 160, 1000, hw, 2, '2way');
                const hasFields = 'recommended' in r && 'computeNodes' in r && 'memoryNodes' in r && 'storageNodes' in r && 'bottleneck' in r;
                return assert(hasFields, 'Returns recommended, computeNodes, memoryNodes, storageNodes, bottleneck', true, hasFields);
            })()
        ]);

        // --- snapToAvailableNodeCount() ---
        // Create a temporary cluster-type select with proper options for these tests
        testSuite('snapToAvailableNodeCount()', 'sizer.js', [
            (() => {
                // Create stub DOM select element with valid options
                let stub = document.getElementById('cluster-type');
                if (!stub) {
                    stub = document.createElement('select');
                    stub.id = 'cluster-type';
                    stub.style.display = 'none';
                    ['single', 'standard', 'rack-aware'].forEach(v => {
                        const opt = document.createElement('option');
                        opt.value = v;
                        opt.text = v;
                        stub.appendChild(opt);
                    });
                    document.body.appendChild(stub);
                }
                stub.value = 'single';
                return assert(snapToAvailableNodeCount(5) === 1, 'Single node cluster always returns 1', 1, snapToAvailableNodeCount(5));
            })(),
            (() => {
                document.getElementById('cluster-type').value = 'standard';
                return assert(snapToAvailableNodeCount(3) === 3, 'Standard: snap 3 ‚Üí 3 (exact match)', 3, snapToAvailableNodeCount(3));
            })(),
            (() => {
                document.getElementById('cluster-type').value = 'standard';
                return assert(snapToAvailableNodeCount(9) === 9, 'Standard: snap 9 ‚Üí 9 (exact match)', 9, snapToAvailableNodeCount(9));
            })(),
            (() => {
                document.getElementById('cluster-type').value = 'standard';
                return assert(snapToAvailableNodeCount(100) === 16, 'Standard: snap 100 ‚Üí 16 (capped at max)', 16, snapToAvailableNodeCount(100));
            })(),
            (() => {
                document.getElementById('cluster-type').value = 'rack-aware';
                return assert(snapToAvailableNodeCount(3) === 4, 'Rack-aware: snap 3 ‚Üí 4 (even numbers only)', 4, snapToAvailableNodeCount(3));
            })(),
            (() => {
                document.getElementById('cluster-type').value = 'rack-aware';
                return assert(snapToAvailableNodeCount(6) === 6, 'Rack-aware: snap 6 ‚Üí 6 (exact match)', 6, snapToAvailableNodeCount(6));
            })(),
            (() => {
                document.getElementById('cluster-type').value = 'rack-aware';
                return assert(snapToAvailableNodeCount(100) === 8, 'Rack-aware: snap 100 ‚Üí 8 (capped at max)', 8, snapToAvailableNodeCount(100));
            })()
        ]);

        // --- buildMaxHardwareConfig() ---
        testSuite('buildMaxHardwareConfig()', 'sizer.js', [
            (() => {
                // With generation info: uses max coreOptions for CPU
                const hw = {
                    coresPerSocket: 24,
                    sockets: 2,
                    totalPhysicalCores: 48,
                    memoryGB: 512,
                    generation: { coreOptions: [8, 16, 24, 32, 48, 64] },
                    diskConfig: { isTiered: false, capacity: { count: 4, sizeGB: 3584, type: 'NVMe' } }
                };
                const maxHw = buildMaxHardwareConfig(hw);
                return assert(maxHw.totalPhysicalCores === 128, 'Max cores = 64 (last option) √ó 2 sockets = 128', 128, maxHw.totalPhysicalCores);
            })(),
            (() => {
                // Memory capped at 1.5 TB (NODE_WEIGHT_PREFERRED_MEMORY_GB = 1536 GB) for small clusters
                // When node count < 10 and memory is not user-set, cap applies
                const hw = {
                    coresPerSocket: 24,
                    sockets: 2,
                    memoryGB: 256,
                    generation: { coreOptions: [8, 24] },
                    diskConfig: { isTiered: false, capacity: { count: 4, sizeGB: 3584, type: 'NVMe' } }
                };
                // Ensure node-count stub exists and is small (< 10), memory not user-set
                let ncStub = document.getElementById('node-count');
                const createdNc = !ncStub;
                if (createdNc) {
                    ncStub = document.createElement('select');
                    ncStub.id = 'node-count';
                    ncStub.style.display = 'none';
                    document.body.appendChild(ncStub);
                }
                const savedNodeVal = ncStub.value;
                ncStub.value = '3';
                const savedMemFlag = _memoryUserSet;
                _memoryUserSet = false;
                const maxHw = buildMaxHardwareConfig(hw);
                _memoryUserSet = savedMemFlag;
                ncStub.value = savedNodeVal;
                if (createdNc) ncStub.remove();
                return assert(maxHw.memoryGB === 1536, 'Preferred max memory is 1536 GB (1.5 TB cap for small clusters)', 1536, maxHw.memoryGB);
            })(),
            (() => {
                // Without generation info: falls back to current coresPerSocket
                const hw = {
                    coresPerSocket: 24,
                    sockets: 2,
                    totalPhysicalCores: 48,
                    memoryGB: 512,
                    diskConfig: { isTiered: false, capacity: { count: 4, sizeGB: 3584, type: 'NVMe' } }
                };
                const maxHw = buildMaxHardwareConfig(hw);
                return assert(maxHw.totalPhysicalCores === 48, 'No generation: falls back to 24 √ó 2 = 48', 48, maxHw.totalPhysicalCores);
            })(),
            (() => {
                // Disk config capacity size is scaled to max (15.36 TB = 15728.64 GB)
                const dc = { isTiered: true, cache: { count: 4 }, capacity: { count: 8, sizeGB: 3584 } };
                const hw = { coresPerSocket: 24, sockets: 2, memoryGB: 512, diskConfig: dc };
                const maxHw = buildMaxHardwareConfig(hw);
                return assert(maxHw.diskConfig.capacity.sizeGB === 15.36 * 1024, 'diskConfig capacity scaled to max 15.36 TB', 15.36 * 1024, maxHw.diskConfig.capacity.sizeGB);
            })(),
            (() => {
                // With Intel Xeon 6 (max 128 cores per socket)
                const hw = {
                    coresPerSocket: 32,
                    sockets: 2,
                    memoryGB: 512,
                    generation: { coreOptions: [16, 24, 32, 48, 64, 72, 86, 96, 128] },
                    diskConfig: { isTiered: false, capacity: { count: 4, sizeGB: 3584, type: 'NVMe' } }
                };
                const maxHw = buildMaxHardwareConfig(hw);
                return assert(maxHw.totalPhysicalCores === 256, 'Xeon 6: 128 √ó 2 = 256 max physical cores', 256, maxHw.totalPhysicalCores);
            })(),
            (() => {
                // Scale-up vs scale-out: maxHwConfig should recommend fewer nodes than default config
                // 100 VMs √ó 4 vCPUs = 400 vCPUs, 100 VMs √ó 16 GB = 1600 GB memory
                const defaultHw = {
                    totalPhysicalCores: 48,   // 24 cores √ó 2
                    memoryGB: 512,
                    diskConfig: { isTiered: false, capacity: { count: 4, sizeGB: 3584, type: 'NVMe' } }
                };
                const maxHw = {
                    totalPhysicalCores: 128,  // 64 cores √ó 2 (generation max)
                    memoryGB: 1024,           // 1 TB
                    diskConfig: { isTiered: false, capacity: { count: 4, sizeGB: 3584, type: 'NVMe' } }
                };
                const recDefault = getRecommendedNodeCount(400, 1600, 5000, defaultHw, 2, '2way');
                const recMax = getRecommendedNodeCount(400, 1600, 5000, maxHw, 2, '2way');
                return assert(recMax.recommended < recDefault.recommended,
                    'maxHwConfig recommends fewer nodes than default', true,
                    recMax.recommended + ' < ' + recDefault.recommended);
            })()
        ]);

        // --- WORKLOAD_DEFAULTS validation ---
        testSuite('WORKLOAD_DEFAULTS', 'sizer.js', [
            assert(WORKLOAD_DEFAULTS.vm.count === 10, 'VM default: 10 count', 10, WORKLOAD_DEFAULTS.vm.count),
            assert(WORKLOAD_DEFAULTS.aks.controlPlaneNodes === 3, 'AKS default: 3 CP nodes', 3, WORKLOAD_DEFAULTS.aks.controlPlaneNodes),
            assert(WORKLOAD_DEFAULTS.aks.workerNodes === 3, 'AKS default: 3 worker nodes', 3, WORKLOAD_DEFAULTS.aks.workerNodes),
            assert(WORKLOAD_DEFAULTS.avd.profile === 'medium', 'AVD default: medium profile', 'medium', WORKLOAD_DEFAULTS.avd.profile),
            assert(WORKLOAD_DEFAULTS.avd.userCount === 50, 'AVD default: 50 users', 50, WORKLOAD_DEFAULTS.avd.userCount)
        ]);

        // --- getWorkloadDetails() ---
        testSuite('getWorkloadDetails()', 'sizer.js', [
            (() => {
                const w = { type: 'vm', vcpus: 4, memory: 16, storage: 100, count: 10 };
                const d = getWorkloadDetails(w);
                return assert(d.includes('10 VMs') && d.includes('4 vCPUs'), 'VM details contain count and vCPUs', true,
                    d.includes('10 VMs') && d.includes('4 vCPUs'));
            })(),
            (() => {
                const w = {
                    type: 'aks', clusterCount: 2,
                    controlPlaneNodes: 3, controlPlaneVcpus: 4, controlPlaneMemory: 8,
                    workerNodes: 3, workerVcpus: 8, workerMemory: 16, workerStorage: 200
                };
                const d = getWorkloadDetails(w);
                return assert(d.includes('2 cluster'), 'AKS details contain cluster count', true, d.includes('2 cluster'));
            })(),
            (() => {
                const w = { type: 'avd', profile: 'medium', userCount: 50 };
                const d = getWorkloadDetails(w);
                return assert(d.includes('50') && d.includes('Medium'), 'AVD details contain user count and profile', true,
                    d.includes('50') && d.includes('Medium'));
            })()
        ]);

        // --- Rack-aware storage and resiliency constraints ---
        // Create stub DOM elements needed for these tests
        (() => {
            // storage-config stub
            let storageStub = document.getElementById('storage-config');
            if (!storageStub) {
                storageStub = document.createElement('select');
                storageStub.id = 'storage-config';
                storageStub.style.display = 'none';
                ['all-flash', 'mixed-flash', 'hybrid'].forEach(v => {
                    const opt = document.createElement('option');
                    opt.value = v;
                    opt.text = v;
                    storageStub.appendChild(opt);
                });
                document.body.appendChild(storageStub);
            }
            // node-count stub
            let nodeStub = document.getElementById('node-count');
            if (!nodeStub) {
                nodeStub = document.createElement('select');
                nodeStub.id = 'node-count';
                nodeStub.style.display = 'none';
                [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16].forEach(v => {
                    const opt = document.createElement('option');
                    opt.value = v;
                    opt.text = v;
                    nodeStub.appendChild(opt);
                });
                document.body.appendChild(nodeStub);
            }
            // resiliency stub
            let resStub = document.getElementById('resiliency');
            if (!resStub) {
                resStub = document.createElement('select');
                resStub.id = 'resiliency';
                resStub.style.display = 'none';
                document.body.appendChild(resStub);
            }
        })();

        testSuite('Rack-aware: All-Flash only', 'sizer.js', [
            (() => {
                // updateStorageForClusterType should disable non-all-flash for rack-aware
                document.getElementById('cluster-type').value = 'rack-aware';
                document.getElementById('storage-config').value = 'hybrid';
                updateStorageForClusterType();
                const storageVal = document.getElementById('storage-config').value;
                const disabled = document.getElementById('storage-config').disabled;
                // Reset
                document.getElementById('cluster-type').value = 'standard';
                updateStorageForClusterType();
                return assert(storageVal === 'all-flash' && disabled === true,
                    'Rack-aware forces all-flash and disables storage dropdown',
                    'all-flash + disabled', storageVal + ' + ' + (disabled ? 'disabled' : 'enabled'));
            })(),
            (() => {
                // Standard cluster should NOT disable storage dropdown
                document.getElementById('cluster-type').value = 'standard';
                updateStorageForClusterType();
                const disabled = document.getElementById('storage-config').disabled;
                return assert(disabled === false, 'Standard cluster: storage dropdown enabled', false, disabled);
            })()
        ]);

        testSuite('Rack-aware: resiliency options', 'sizer.js', [
            (() => {
                // 2-node rack-aware: only 2-way mirror
                document.getElementById('cluster-type').value = 'rack-aware';
                document.getElementById('node-count').value = '2';
                updateResiliencyOptions();
                const opts = Array.from(document.getElementById('resiliency').options).map(o => o.value);
                // Reset
                document.getElementById('cluster-type').value = 'standard';
                document.getElementById('node-count').value = '3';
                updateResiliencyOptions();
                return assert(opts.length === 1 && opts[0] === '2way',
                    '2-node rack-aware: only 2-way mirror', '["2way"]', JSON.stringify(opts));
            })(),
            (() => {
                // 4-node rack-aware: only 4-way mirror
                document.getElementById('cluster-type').value = 'rack-aware';
                document.getElementById('node-count').value = '4';
                updateResiliencyOptions();
                const opts = Array.from(document.getElementById('resiliency').options).map(o => o.value);
                document.getElementById('cluster-type').value = 'standard';
                document.getElementById('node-count').value = '3';
                updateResiliencyOptions();
                return assert(opts.length === 1 && opts[0] === '4way',
                    '4-node rack-aware: only 4-way mirror', '["4way"]', JSON.stringify(opts));
            })(),
            (() => {
                // 8-node rack-aware: only 4-way mirror
                document.getElementById('cluster-type').value = 'rack-aware';
                document.getElementById('node-count').value = '8';
                updateResiliencyOptions();
                const opts = Array.from(document.getElementById('resiliency').options).map(o => o.value);
                document.getElementById('cluster-type').value = 'standard';
                document.getElementById('node-count').value = '3';
                updateResiliencyOptions();
                return assert(opts.length === 1 && opts[0] === '4way',
                    '8-node rack-aware: only 4-way mirror', '["4way"]', JSON.stringify(opts));
            })(),
            (() => {
                // 4-way mirror has 4x multiplier (25% efficiency) ‚Äî via RESILIENCY_CONFIG
                return assert(RESILIENCY_CONFIG['4way'].multiplier === 4,
                    '4-way mirror: 4x raw storage (25% efficiency)', 4, RESILIENCY_CONFIG['4way'].multiplier);
            })()
        ]);

        // ========================================================================
        // v0.15.95 NEW FEATURE TESTS
        // ========================================================================
        sectionHeader('üÜï v0.15.95 New Features');

        // --- Feature 1 & 11: getVcpuRatio() helper and vCPU ratio dropdown ---
        testSuite('getVcpuRatio() - vCPU overcommit ratio', 'sizer.js', [
            (() => {
                // Create or reuse vcpu-ratio stub
                let stub = document.getElementById('vcpu-ratio');
                if (!stub) {
                    stub = document.createElement('select');
                    stub.id = 'vcpu-ratio';
                    stub.style.display = 'none';
                    [1, 2, 4, 5, 6].forEach(v => {
                        const opt = document.createElement('option');
                        opt.value = v;
                        opt.text = v + ':1';
                        stub.appendChild(opt);
                    });
                    document.body.appendChild(stub);
                }
                stub.value = '4';
                const result = getVcpuRatio();
                return assert(result === 4, 'Default ratio is 4:1', 4, result);
            })(),
            (() => {
                document.getElementById('vcpu-ratio').value = '1';
                const result = getVcpuRatio();
                return assert(result === 1, 'Ratio 1:1 (no overcommit)', 1, result);
            })(),
            (() => {
                document.getElementById('vcpu-ratio').value = '2';
                const result = getVcpuRatio();
                return assert(result === 2, 'Ratio 2:1', 2, result);
            })(),
            (() => {
                document.getElementById('vcpu-ratio').value = '5';
                const result = getVcpuRatio();
                return assert(result === 5, 'Ratio 5:1', 5, result);
            })(),
            (() => {
                document.getElementById('vcpu-ratio').value = '6';
                const result = getVcpuRatio();
                return assert(result === 6, 'Ratio 6:1', 6, result);
            })(),
            (() => {
                // Test fallback when element is missing
                const el = document.getElementById('vcpu-ratio');
                el.id = 'vcpu-ratio-temp';
                const result = getVcpuRatio();
                el.id = 'vcpu-ratio';
                return assert(result === 4, 'Falls back to 4 when dropdown missing', 4, result);
            })(),
            (() => {
                // Restore default for subsequent tests
                document.getElementById('vcpu-ratio').value = '4';
                return assert(true, 'Restored vcpu-ratio to default 4:1', true, true);
            })()
        ]);

        // --- Feature 2: getGpuLabel() helper ---
        testSuite('getGpuLabel() - GPU label formatting', 'sizer.js', [
            (() => {
                const result = getGpuLabel('a2');
                return assert(result === 'NVIDIA A2 (16 GB VRAM, 60W TDP)',
                    'A2 label', 'NVIDIA A2 (16 GB VRAM, 60W TDP)', result);
            })(),
            (() => {
                const result = getGpuLabel('a16');
                return assert(result === 'NVIDIA A16 (64 GB VRAM, 250W TDP)',
                    'A16 label', 'NVIDIA A16 (64 GB VRAM, 250W TDP)', result);
            })(),
            (() => {
                const result = getGpuLabel('l4');
                return assert(result === 'NVIDIA L4 (24 GB VRAM, 72W TDP)',
                    'L4 label', 'NVIDIA L4 (24 GB VRAM, 72W TDP)', result);
            })(),
            (() => {
                const result = getGpuLabel('l40');
                return assert(result === 'NVIDIA L40 (48 GB VRAM, 300W TDP)',
                    'L40 label', 'NVIDIA L40 (48 GB VRAM, 300W TDP)', result);
            })(),
            (() => {
                const result = getGpuLabel('l40s');
                return assert(result === 'NVIDIA L40S (48 GB VRAM, 350W TDP)',
                    'L40S label', 'NVIDIA L40S (48 GB VRAM, 350W TDP)', result);
            })(),
            (() => {
                const result = getGpuLabel('nonexistent');
                return assert(result === 'nonexistent', 'Unknown GPU returns key as-is', 'nonexistent', result);
            })(),
            (() => {
                const result = getGpuLabel('');
                return assert(result === 'Unknown', 'Empty GPU type returns Unknown', 'Unknown', result);
            })(),
            (() => {
                const result = getGpuLabel(null);
                return assert(result === 'Unknown', 'Null GPU type returns Unknown', 'Unknown', result);
            })()
        ]);

        // --- Feature 3: GPU_MODELS constant ---
        testSuite('GPU_MODELS constant', 'sizer.js', [
            assert(GPU_MODELS.a2 !== undefined, 'A2 model defined', true, GPU_MODELS.a2 !== undefined),
            assert(GPU_MODELS.a16 !== undefined, 'A16 model defined', true, GPU_MODELS.a16 !== undefined),
            assert(GPU_MODELS.l4 !== undefined, 'L4 model defined', true, GPU_MODELS.l4 !== undefined),
            assert(GPU_MODELS.l40 !== undefined, 'L40 model defined', true, GPU_MODELS.l40 !== undefined),
            assert(GPU_MODELS.l40s !== undefined, 'L40S model defined', true, GPU_MODELS.l40s !== undefined),
            assert(Object.keys(GPU_MODELS).length === 5, 'GPU_MODELS has exactly 5 models', 5, Object.keys(GPU_MODELS).length),
            assert(GPU_MODELS.a2.vramGB === 16, 'A2: 16 GB VRAM', 16, GPU_MODELS.a2.vramGB),
            assert(GPU_MODELS.a2.tdpW === 60, 'A2: 60W TDP', 60, GPU_MODELS.a2.tdpW),
            assert(GPU_MODELS.a16.vramGB === 64, 'A16: 64 GB VRAM', 64, GPU_MODELS.a16.vramGB),
            assert(GPU_MODELS.a16.tdpW === 250, 'A16: 250W TDP', 250, GPU_MODELS.a16.tdpW),
            assert(GPU_MODELS.l4.vramGB === 24, 'L4: 24 GB VRAM', 24, GPU_MODELS.l4.vramGB),
            assert(GPU_MODELS.l4.tdpW === 72, 'L4: 72W TDP', 72, GPU_MODELS.l4.tdpW),
            assert(GPU_MODELS.l40.vramGB === 48, 'L40: 48 GB VRAM', 48, GPU_MODELS.l40.vramGB),
            assert(GPU_MODELS.l40.tdpW === 300, 'L40: 300W TDP', 300, GPU_MODELS.l40.tdpW),
            assert(GPU_MODELS.l40s.vramGB === 48, 'L40S: 48 GB VRAM', 48, GPU_MODELS.l40s.vramGB),
            assert(GPU_MODELS.l40s.tdpW === 350, 'L40S: 350W TDP', 350, GPU_MODELS.l40s.tdpW),
            // Every model has required fields
            assert(Object.values(GPU_MODELS).every(m => m.name && m.vramGB > 0 && m.tdpW > 0),
                'All GPU models have name, vramGB, and tdpW', true,
                Object.values(GPU_MODELS).every(m => m.name && m.vramGB > 0 && m.tdpW > 0))
        ]);

        // --- Feature 4: Intel Xeon D-2700 (intel_edge) CPU generation ---
        testSuite('CPU_GENERATIONS: intel_edge (Xeon D-2700)', 'sizer.js', [
            assert(CPU_GENERATIONS.intel_edge !== undefined, 'intel_edge category exists', true, CPU_GENERATIONS.intel_edge !== undefined),
            assert(CPU_GENERATIONS.intel_edge.length >= 1, 'intel_edge has at least 1 generation', '>=1', CPU_GENERATIONS.intel_edge.length),
            (() => {
                const gen = CPU_GENERATIONS.intel_edge[0];
                return assert(gen.id === 'xeon-d-27xx', 'First gen id is xeon-d-27xx', 'xeon-d-27xx', gen.id);
            })(),
            (() => {
                const gen = CPU_GENERATIONS.intel_edge[0];
                return assert(gen.name.includes('D-2700'), 'Name includes D-2700', true, gen.name.includes('D-2700'));
            })(),
            (() => {
                const gen = CPU_GENERATIONS.intel_edge[0];
                return assert(gen.coreOptions.length > 0, 'Has core options', '>0', gen.coreOptions.length);
            })(),
            (() => {
                const gen = CPU_GENERATIONS.intel_edge[0];
                const hasCoreRange = gen.coreOptions.includes(4) && gen.coreOptions.includes(20);
                return assert(hasCoreRange, 'Core options include 4 and 20', true, hasCoreRange);
            })(),
            (() => {
                const gen = CPU_GENERATIONS.intel_edge[0];
                return assert(gen.defaultCores === 8, 'Default cores is 8', 8, gen.defaultCores);
            })(),
            (() => {
                const gen = CPU_GENERATIONS.intel_edge[0];
                return assert(gen.id && gen.name && gen.defaultCores, 'Has required fields (id, name, defaultCores)', true,
                    gen.id && gen.name && gen.defaultCores ? true : false);
            })(),
            (() => {
                const gen = CPU_GENERATIONS.intel_edge[0];
                return assert(gen.architecture === 'Sunny Cove', 'Architecture is Sunny Cove', 'Sunny Cove', gen.architecture);
            })(),
            (() => {
                const gen = CPU_GENERATIONS.intel_edge[0];
                return assert(gen.memoryType === 'DDR4-3200', 'Memory type is DDR4-3200', 'DDR4-3200', gen.memoryType);
            })()
        ]);

        // --- Feature 5: updateStorageForClusterType() single-node hybrid blocking ---
        testSuite('Single-node: All-Flash only (updateStorageForClusterType)', 'sizer.js', [
            (() => {
                // Single-node should force all-flash and disable storage dropdown
                document.getElementById('cluster-type').value = 'single';
                document.getElementById('storage-config').value = 'hybrid';
                updateStorageForClusterType();
                const storageVal = document.getElementById('storage-config').value;
                const disabled = document.getElementById('storage-config').disabled;
                // Reset
                document.getElementById('cluster-type').value = 'standard';
                updateStorageForClusterType();
                return assert(storageVal === 'all-flash' && disabled === true,
                    'Single-node forces all-flash and disables storage dropdown',
                    'all-flash + disabled', storageVal + ' + ' + (disabled ? 'disabled' : 'enabled'));
            })(),
            (() => {
                // Single-node with mixed-flash should also be forced to all-flash
                document.getElementById('cluster-type').value = 'single';
                document.getElementById('storage-config').value = 'mixed-flash';
                updateStorageForClusterType();
                const storageVal = document.getElementById('storage-config').value;
                // Reset
                document.getElementById('cluster-type').value = 'standard';
                updateStorageForClusterType();
                return assert(storageVal === 'all-flash',
                    'Single-node forces mixed-flash ‚Üí all-flash',
                    'all-flash', storageVal);
            })(),
            (() => {
                // Standard cluster should NOT disable storage dropdown
                document.getElementById('cluster-type').value = 'standard';
                updateStorageForClusterType();
                const disabled = document.getElementById('storage-config').disabled;
                return assert(disabled === false,
                    'Standard cluster: storage dropdown remains enabled after single-node test',
                    false, disabled);
            })()
        ]);

        // --- Features 6 & 7: Minimum 2 capacity disks and minimum 2 cache disks ---
        // Create stub DOM elements for disk count dropdowns (these exist in sizer/index.html but not in test harness)
        (() => {
            // capacity-disk-count stub (all-flash)
            let capStub = document.getElementById('capacity-disk-count');
            if (!capStub) {
                capStub = document.createElement('select');
                capStub.id = 'capacity-disk-count';
                capStub.style.display = 'none';
                for (let v = 2; v <= 24; v++) {
                    const opt = document.createElement('option');
                    opt.value = v;
                    opt.text = v;
                    capStub.appendChild(opt);
                }
                document.body.appendChild(capStub);
            }
            // cache-disk-count stub (hybrid)
            let cacheStub = document.getElementById('cache-disk-count');
            if (!cacheStub) {
                cacheStub = document.createElement('select');
                cacheStub.id = 'cache-disk-count';
                cacheStub.style.display = 'none';
                for (let v = 2; v <= 8; v++) {
                    const opt = document.createElement('option');
                    opt.value = v;
                    opt.text = v;
                    cacheStub.appendChild(opt);
                }
                document.body.appendChild(cacheStub);
            }
            // tiered-capacity-disk-count stub (hybrid)
            let tieredStub = document.getElementById('tiered-capacity-disk-count');
            if (!tieredStub) {
                tieredStub = document.createElement('select');
                tieredStub.id = 'tiered-capacity-disk-count';
                tieredStub.style.display = 'none';
                for (let v = 2; v <= 16; v++) {
                    const opt = document.createElement('option');
                    opt.value = v;
                    opt.text = v;
                    tieredStub.appendChild(opt);
                }
                document.body.appendChild(tieredStub);
            }
        })();

        testSuite('Minimum disk counts: 2 capacity, 2 cache', 'sizer.js', [
            (() => {
                // Capacity disk dropdown starts at 2 (not 1)
                const capacitySelect = document.getElementById('capacity-disk-count');
                const firstOption = capacitySelect.options[0];
                return assert(parseInt(firstOption.value) === 2,
                    'Capacity disk dropdown minimum is 2',
                    2, parseInt(firstOption.value));
            })(),
            (() => {
                // Tiered capacity disk dropdown starts at 2
                const firstOpt = document.getElementById('tiered-capacity-disk-count').options[0];
                return assert(parseInt(firstOpt.value) >= 2,
                    'Tiered capacity disk dropdown minimum is ‚â• 2',
                    '>=2', parseInt(firstOpt.value));
            })(),
            (() => {
                // Cache disk dropdown starts at 2 (not 1)
                const firstOption = document.getElementById('cache-disk-count').options[0];
                return assert(parseInt(firstOption.value) === 2,
                    'Cache disk dropdown minimum is 2',
                    2, parseInt(firstOption.value));
            })(),
            (() => {
                // Capacity disk count cannot be set to 1
                const capacitySelect = document.getElementById('capacity-disk-count');
                const hasOptionOne = Array.from(capacitySelect.options).some(o => parseInt(o.value) === 1);
                return assert(!hasOptionOne,
                    'Capacity disk dropdown does not include option for 1 disk',
                    false, hasOptionOne);
            })(),
            (() => {
                // Cache disk count cannot be set to 1
                const cacheSelect = document.getElementById('cache-disk-count');
                const hasOptionOne = Array.from(cacheSelect.options).some(o => parseInt(o.value) === 1);
                return assert(!hasOptionOne,
                    'Cache disk dropdown does not include option for 1 disk',
                    false, hasOptionOne);
            })()
        ]);

        // --- Tiered disk constraints: 2U chassis limit (max 8 cache + 16 capacity = 24 total) ---
        // Applies to both hybrid and mixed-flash configurations
        testSuite('Tiered disk constraints (2U chassis limit)', 'sizer.js', [
            (() => {
                // MAX_CACHE_DISK_COUNT should be 8
                return assert(MAX_CACHE_DISK_COUNT === 8,
                    'MAX_CACHE_DISK_COUNT is 8 (2U chassis limit)',
                    8, MAX_CACHE_DISK_COUNT);
            })(),
            (() => {
                // MAX_TIERED_CAPACITY_DISK_COUNT should be 16
                return assert(MAX_TIERED_CAPACITY_DISK_COUNT === 16,
                    'MAX_TIERED_CAPACITY_DISK_COUNT is 16 (8 cache + 16 capacity = 24)',
                    16, MAX_TIERED_CAPACITY_DISK_COUNT);
            })(),
            (() => {
                // Cache disk dropdown max value should be 8
                const cacheSelect = document.getElementById('cache-disk-count');
                const lastOption = cacheSelect.options[cacheSelect.options.length - 1];
                return assert(parseInt(lastOption.value) === 8,
                    'Cache disk dropdown maximum is 8',
                    8, parseInt(lastOption.value));
            })(),
            (() => {
                // Cache disk dropdown should NOT include option 9 or higher
                const cacheSelect = document.getElementById('cache-disk-count');
                const hasNineOrMore = Array.from(cacheSelect.options).some(o => parseInt(o.value) >= 9);
                return assert(!hasNineOrMore,
                    'Cache disk dropdown excludes values >= 9',
                    false, hasNineOrMore);
            })(),
            (() => {
                // Tiered capacity disk dropdown max value should be 16
                const tieredSelect = document.getElementById('tiered-capacity-disk-count');
                const lastOpt = tieredSelect.options[tieredSelect.options.length - 1];
                return assert(parseInt(lastOpt.value) === 16,
                    'Tiered capacity disk dropdown maximum is 16',
                    16, parseInt(lastOpt.value));
            })(),
            (() => {
                // Tiered capacity disk dropdown should NOT include option 17 or higher
                const tieredSelect = document.getElementById('tiered-capacity-disk-count');
                const hasSeventeenOrMore = Array.from(tieredSelect.options).some(o => parseInt(o.value) >= 17);
                return assert(!hasSeventeenOrMore,
                    'Tiered capacity disk dropdown excludes values >= 17',
                    false, hasSeventeenOrMore);
            })(),
            (() => {
                // enforceCacheToCapacityRatio (hybrid): with 16 capacity, cache should be ceil(16/2)=8, capped at 8
                // Stub storage-tiering if needed
                let tieringStub = document.getElementById('storage-tiering');
                if (!tieringStub) {
                    tieringStub = document.createElement('select');
                    tieringStub.id = 'storage-tiering';
                    tieringStub.style.display = 'none';
                    ['ssd-cache-hdd-capacity', 'nvme-cache-hdd-capacity', 'nvme-cache-ssd-capacity'].forEach(v => {
                        const opt = document.createElement('option');
                        opt.value = v;
                        opt.text = v;
                        tieringStub.appendChild(opt);
                    });
                    document.body.appendChild(tieringStub);
                }

                const storageConfig = document.getElementById('storage-config');
                const storageTiering = document.getElementById('storage-tiering');
                const tieredCapacity = document.getElementById('tiered-capacity-disk-count');
                const cacheDisk = document.getElementById('cache-disk-count');
                const prevStorage = storageConfig.value;
                const prevTiering = storageTiering.value;

                storageConfig.value = 'hybrid';
                storageTiering.value = 'ssd-cache-hdd-capacity';
                tieredCapacity.value = '16';
                cacheDisk.value = '2';
                enforceCacheToCapacityRatio();
                const result = parseInt(cacheDisk.value);

                storageConfig.value = prevStorage;
                storageTiering.value = prevTiering;
                return assert(result === 8,
                    'Hybrid: 16 capacity ‚Üí cache enforced to 8 (ceil(16/2) capped at max)',
                    8, result);
            })(),
            (() => {
                // Total tiered disks never exceeds 24: 8 cache + 16 capacity = 24
                const totalMax = MAX_CACHE_DISK_COUNT + MAX_TIERED_CAPACITY_DISK_COUNT;
                return assert(totalMax === 24,
                    'Max total tiered disks = 8 cache + 16 capacity = 24 (2U chassis)',
                    24, totalMax);
            })(),
            (() => {
                // enforceCacheToCapacityRatio (mixed-flash): capacity capped at 16
                const storageConfig = document.getElementById('storage-config');
                const storageTiering = document.getElementById('storage-tiering');
                const tieredCapacity = document.getElementById('tiered-capacity-disk-count');

                // Add mixed-flash option to storage-config stub if not present
                const scOpts = Array.from(storageConfig.options).map(o => o.value);
                if (!scOpts.includes('mixed-flash')) {
                    const mfOpt = document.createElement('option');
                    mfOpt.value = 'mixed-flash';
                    mfOpt.text = 'Mixed All-Flash';
                    storageConfig.appendChild(mfOpt);
                }

                const prevStorage = storageConfig.value;
                const prevTiering = storageTiering.value;
                const prevCapacity = tieredCapacity.value;

                // Add option value 20 temporarily to test capping
                const opt20 = document.createElement('option');
                opt20.value = '20';
                opt20.text = '20';
                tieredCapacity.appendChild(opt20);

                storageConfig.value = 'mixed-flash';
                storageTiering.value = 'nvme-cache-ssd-capacity';
                tieredCapacity.value = '20'; // exceeds limit
                enforceCacheToCapacityRatio();
                const result = parseInt(tieredCapacity.value);

                storageConfig.value = prevStorage;
                storageTiering.value = prevTiering;
                tieredCapacity.value = prevCapacity;
                tieredCapacity.removeChild(opt20);
                return assert(result === 16,
                    'Mixed-flash: capacity capped at 16 (was set to 20)',
                    16, result);
            })(),
            (() => {
                // enforceCacheToCapacityRatio (mixed-flash): cache capped at 8
                const storageConfig = document.getElementById('storage-config');
                const storageTiering = document.getElementById('storage-tiering');
                const cacheDisk = document.getElementById('cache-disk-count');
                const tieredCapacity = document.getElementById('tiered-capacity-disk-count');

                const prevStorage = storageConfig.value;
                const prevTiering = storageTiering.value;
                const prevCache = cacheDisk.value;
                const prevCapacity = tieredCapacity.value;

                // Add option value 10 to cache stub temporarily for this test
                const opt10 = document.createElement('option');
                opt10.value = '10';
                opt10.text = '10';
                cacheDisk.appendChild(opt10);

                storageConfig.value = 'mixed-flash';
                storageTiering.value = 'nvme-cache-ssd-capacity';
                tieredCapacity.value = '8';
                cacheDisk.value = '10'; // exceeds limit
                enforceCacheToCapacityRatio();
                const result = parseInt(cacheDisk.value);

                storageConfig.value = prevStorage;
                storageTiering.value = prevTiering;
                cacheDisk.value = prevCache;
                tieredCapacity.value = prevCapacity;
                cacheDisk.removeChild(opt10);
                return assert(result === 8,
                    'Mixed-flash: cache capped at 8 (was set to 10)',
                    8, result);
            })(),
            (() => {
                // Mixed-flash does NOT enforce 1:2 ratio (only hybrid does)
                const storageConfig = document.getElementById('storage-config');
                const storageTiering = document.getElementById('storage-tiering');
                const tieredCapacity = document.getElementById('tiered-capacity-disk-count');
                const cacheDisk = document.getElementById('cache-disk-count');

                const prevStorage = storageConfig.value;
                const prevTiering = storageTiering.value;
                const prevCapacity = tieredCapacity.value;
                const prevCache = cacheDisk.value;

                storageConfig.value = 'mixed-flash';
                storageTiering.value = 'nvme-cache-ssd-capacity';
                tieredCapacity.value = '16';
                cacheDisk.value = '2'; // low but mixed-flash shouldn't force it up
                enforceCacheToCapacityRatio();
                const result = parseInt(cacheDisk.value);

                storageConfig.value = prevStorage;
                storageTiering.value = prevTiering;
                tieredCapacity.value = prevCapacity;
                cacheDisk.value = prevCache;
                return assert(result === 2,
                    'Mixed-flash: no 1:2 ratio enforcement (cache stays at 2)',
                    2, result);
            })()
        ]);

        // --- Feature 8: Cache metadata memory overhead note (4 GB per TB) ---
        // This is in generateSizingNotes(). We test the logic inline.
        testSuite('Cache metadata memory overhead note (4 GB per TB)', 'sizer.js', [
            (() => {
                // Tiered config with cache drives: should generate metadata note
                const hwConfig = {
                    diskConfig: {
                        isTiered: true,
                        cache: { count: 4, sizeGB: 1638.4, type: 'NVMe' },  // 4 √ó 1.6 TB = 6.4 TB cache
                        capacity: { count: 8, sizeGB: 3584, type: 'SSD' }
                    }
                };
                const dc = hwConfig.diskConfig;
                const cacheTB = (dc.cache.count * dc.cache.sizeGB) / 1024;
                const metadataGB = Math.ceil(cacheTB * 4);
                // 6.4 TB √ó 4 GB/TB = 25.6 ‚Üí ceil = 26 GB
                return assert(metadataGB === 26,
                    '4 √ó 1.6 TB cache ‚Üí 26 GB metadata overhead per node',
                    26, metadataGB);
            })(),
            (() => {
                // Non-tiered config: no cache metadata
                const hwConfig = {
                    diskConfig: {
                        isTiered: false,
                        capacity: { count: 4, sizeGB: 3584, type: 'NVMe' }
                    }
                };
                const dc = hwConfig.diskConfig;
                let cacheTB = 0;
                if (dc.isTiered && dc.cache) {
                    cacheTB = (dc.cache.count * dc.cache.sizeGB) / 1024;
                }
                return assert(cacheTB === 0,
                    'Non-tiered config: no cache metadata overhead',
                    0, cacheTB);
            })(),
            (() => {
                // Small cache: 2 √ó 0.8 TB = 1.6 TB ‚Üí 7 GB
                const cacheTB = (2 * 819.2) / 1024; // 1.6 TB
                const metadataGB = Math.ceil(cacheTB * 4);
                return assert(metadataGB === 7,
                    '2 √ó 0.8 TB cache ‚Üí 7 GB metadata overhead',
                    7, metadataGB);
            })()
        ]);

        // --- Feature 9: 400 TB per-machine storage validation ---
        testSuite('400 TB per-machine storage validation', 'sizer.js', [
            (() => {
                // Under limit: 24 √ó 15.36 TB = 368.64 TB (OK)
                const dc = { capacity: { count: 24, sizeGB: 15728.64 } };
                const rawStoragePerMachineTB = (dc.capacity.count * dc.capacity.sizeGB) / 1024;
                return assert(rawStoragePerMachineTB <= 400,
                    '24 √ó 15.36 TB = ~368.6 TB ‚Äî under 400 TB limit',
                    '<=400', rawStoragePerMachineTB.toFixed(1));
            })(),
            (() => {
                // Over limit: capacity + cache exceeds 400 TB
                const dc = {
                    isTiered: true,
                    cache: { count: 12, sizeGB: 3584 },       // 12 √ó 3.5 TB = 42 TB
                    capacity: { count: 24, sizeGB: 15728.64 } // 24 √ó 15.36 TB ‚âà 368.6 TB
                };
                let rawStoragePerMachineTB = (dc.capacity.count * dc.capacity.sizeGB) / 1024;
                if (dc.isTiered && dc.cache) {
                    rawStoragePerMachineTB += (dc.cache.count * dc.cache.sizeGB) / 1024;
                }
                // 368.6 + 42 = ~410.6 TB ‚Üí exceeds 400 TB
                return assert(rawStoragePerMachineTB > 400,
                    'Capacity (~368.6 TB) + Cache (~42 TB) = ~410.6 TB ‚Äî exceeds 400 TB limit',
                    '>400', rawStoragePerMachineTB.toFixed(1));
            })(),
            (() => {
                // Exactly at limit: non-tiered 400 TB
                const dc = { capacity: { count: 24, sizeGB: 400 * 1024 / 24 } };
                const rawStoragePerMachineTB = (dc.capacity.count * dc.capacity.sizeGB) / 1024;
                return assert(Math.abs(rawStoragePerMachineTB - 400) < 0.01,
                    'Exactly 400 TB per machine ‚Äî at limit (not exceeding)',
                    '~400', rawStoragePerMachineTB.toFixed(1));
            })()
        ]);

        // --- Feature 10: 4 PB cluster storage cap warning ---
        testSuite('4 PB cluster storage cap validation', 'sizer.js', [
            (() => {
                // Under limit: 8 nodes √ó 24 √ó 15.36 TB = ~2949 TB (OK)
                const nodeCount = 8;
                const dc = { capacity: { count: 24, sizeGB: 15728.64 } };
                const rawPerNodeTB = (dc.capacity.count * dc.capacity.sizeGB) / 1024;
                const totalClusterRawTB = rawPerNodeTB * nodeCount;
                return assert(totalClusterRawTB <= 4000,
                    '8 nodes √ó 24 √ó 15.36 TB ‚âà 2949 TB ‚Äî under 4 PB limit',
                    '<=4000', totalClusterRawTB.toFixed(0));
            })(),
            (() => {
                // Over limit: 16 nodes √ó 24 √ó 15.36 TB = ~5898 TB
                const nodeCount = 16;
                const dc = { capacity: { count: 24, sizeGB: 15728.64 } };
                const rawPerNodeTB = (dc.capacity.count * dc.capacity.sizeGB) / 1024;
                const totalClusterRawTB = rawPerNodeTB * nodeCount;
                return assert(totalClusterRawTB > 4000,
                    '16 nodes √ó 24 √ó 15.36 TB ‚âà 5898 TB ‚Äî exceeds 4 PB limit',
                    '>4000', totalClusterRawTB.toFixed(0));
            })(),
            (() => {
                // Tiered: cache adds to per-node total
                const nodeCount = 12;
                const dc = {
                    isTiered: true,
                    cache: { count: 12, sizeGB: 3584 },       // 42 TB cache
                    capacity: { count: 24, sizeGB: 15728.64 } // ~368.6 TB capacity
                };
                let rawPerNodeTB = (dc.capacity.count * dc.capacity.sizeGB) / 1024;
                if (dc.isTiered && dc.cache) {
                    rawPerNodeTB += (dc.cache.count * dc.cache.sizeGB) / 1024;
                }
                const totalClusterRawTB = rawPerNodeTB * nodeCount;
                return assert(totalClusterRawTB > 4000,
                    '12 nodes √ó (~410.6 TB each) ‚âà 4928 TB ‚Äî exceeds 4 PB limit',
                    '>4000', totalClusterRawTB.toFixed(0));
            })()
        ]);

        // --- Feature 12: Memory capacity bar 32 GB host overhead subtraction ---
        testSuite('Host overhead: 32 GB subtraction in node recommendations', 'sizer.js', [
            (() => {
                // 64 GB memory - 32 GB overhead = 32 GB usable
                // 100 GB workload memory / 32 GB usable = 4 memory-driven nodes
                const hw = {
                    totalPhysicalCores: 256,
                    memoryGB: 64,
                    diskConfig: { isTiered: false, capacity: { count: 24, sizeGB: 3584, type: 'NVMe' } }
                };
                const r = getRecommendedNodeCount(10, 100, 100, hw, 2, '2way');
                // With 32 GB overhead: usable per node = 32 GB ‚Üí 100/32 = 4 memory nodes
                // Without overhead: usable per node = 64 GB ‚Üí 100/64 = 2 memory nodes
                return assert(r.memoryNodes >= 4,
                    '64 GB node memory - 32 GB overhead = 32 GB usable ‚Üí ‚â•4 memory nodes for 100 GB',
                    '>=4', r.memoryNodes);
            })(),
            (() => {
                // Edge case: exactly 32 GB memory ‚Üí 0 usable ‚Üí bottleneck is memory
                const hw = {
                    totalPhysicalCores: 256,
                    memoryGB: 32,
                    diskConfig: { isTiered: false, capacity: { count: 24, sizeGB: 3584, type: 'NVMe' } }
                };
                const r = getRecommendedNodeCount(1, 1, 100, hw, 2, '2way');
                return assert(r.bottleneck === 'memory',
                    '32 GB node memory - 32 GB overhead = 0 usable ‚Üí memory bottleneck',
                    'memory', r.bottleneck);
            })(),
            (() => {
                // 256 GB memory - 32 GB overhead = 224 GB usable
                const hw = {
                    totalPhysicalCores: 256,
                    memoryGB: 256,
                    diskConfig: { isTiered: false, capacity: { count: 24, sizeGB: 3584, type: 'NVMe' } }
                };
                const r = getRecommendedNodeCount(10, 224, 100, hw, 2, '2way');
                // 224 GB / 224 GB usable per node = 1 memory node ‚Üí exactly fits 1 node
                return assert(r.memoryNodes === 1,
                    '256 GB node - 32 GB overhead = 224 GB usable: 224 GB workload fits in 1 memory node',
                    1, r.memoryNodes);
            })()
        ]);

        // --- Feature 13: Host overhead sizing note ---
        // The note is generated in generateSizingNotes() as a static string.
        // We verify the constant value and the note text pattern.
        testSuite('Host overhead sizing note', 'sizer.js', [
            (() => {
                // Verify the 32 GB overhead constant is used in getRecommendedNodeCount
                // by checking that 512 GB - overhead gives different result than 512 GB raw
                const hwWith512 = {
                    totalPhysicalCores: 128,
                    memoryGB: 512,
                    diskConfig: { isTiered: false, capacity: { count: 4, sizeGB: 3584, type: 'NVMe' } }
                };
                const r = getRecommendedNodeCount(10, 490, 100, hwWith512, 2, '2way');
                // Without overhead: 490/512 = 1 node. With overhead: 490/(512-32) = 490/480 ‚âà 2 nodes
                return assert(r.memoryNodes >= 2,
                    'Overhead impacts node count: 490 GB workload needs ‚â•2 nodes at 512 GB/node (480 usable)',
                    '>=2', r.memoryNodes);
            })()
        ]);

        // --- Feature 1 revisited: getVcpuRatio() affects getRecommendedNodeCount ---
        testSuite('vCPU ratio affects node recommendations', 'sizer.js', [
            (() => {
                // With 4:1 ratio: 200 vCPUs / (48 cores √ó 4) = 200/192 ‚âà 2 compute nodes
                document.getElementById('vcpu-ratio').value = '4';
                const hw = {
                    totalPhysicalCores: 48,
                    memoryGB: 2048,
                    diskConfig: { isTiered: false, capacity: { count: 24, sizeGB: 3584, type: 'NVMe' } }
                };
                const r4 = getRecommendedNodeCount(200, 10, 100, hw, 2, '2way');

                // With 1:1 ratio: 200 vCPUs / (48 cores √ó 1) = 200/48 ‚âà 5 compute nodes
                document.getElementById('vcpu-ratio').value = '1';
                const r1 = getRecommendedNodeCount(200, 10, 100, hw, 2, '2way');

                // Restore
                document.getElementById('vcpu-ratio').value = '4';

                return assert(r1.computeNodes > r4.computeNodes,
                    '1:1 ratio needs more compute nodes than 4:1 for same workload',
                    r1.computeNodes + ' > ' + r4.computeNodes,
                    r1.computeNodes + ' > ' + r4.computeNodes);
            })()
        ]);

        // ========================================================================
        // NODE-PREFERENCE SCALING TESTS
        // ========================================================================
        sectionHeader('üîÑ Sizer: Node-Preference Scaling (prefer nodes over ratio/memory)');

        // --- Constants validation ---
        testSuite('NODE_WEIGHT_PREFERRED_MEMORY constants', 'sizer.js', [
            assert(NODE_WEIGHT_PREFERRED_MEMORY_GB === 1536,
                'Small cluster memory cap = 1536 GB (1.5 TB)', 1536, NODE_WEIGHT_PREFERRED_MEMORY_GB),
            assert(NODE_WEIGHT_PREFERRED_MEMORY_LARGE_CLUSTER_GB === 2048,
                'Large cluster memory cap = 2048 GB (2 TB)', 2048, NODE_WEIGHT_PREFERRED_MEMORY_LARGE_CLUSTER_GB),
            assert(NODE_WEIGHT_LARGE_CLUSTER_THRESHOLD === 10,
                'Large cluster threshold = 10 nodes', 10, NODE_WEIGHT_LARGE_CLUSTER_THRESHOLD)
        ]);

        // --- buildMaxHardwareConfig: deterministic memory cap (always 1.5 TB) ---
        // buildMaxHardwareConfig no longer reads the current node count from the DOM
        // to determine the memory cap. It always uses NODE_WEIGHT_PREFERRED_MEMORY_GB
        // (1536 GB) to ensure deterministic results regardless of previous state.
        // This prevents adding growth from reducing the recommended node count.
        testSuite('buildMaxHardwareConfig() - deterministic memory cap', 'sizer.js', [
            (() => {
                // Even with 12 nodes displayed, memory cap should be 1536 (not 2048)
                const hw = {
                    coresPerSocket: 24,
                    sockets: 2,
                    memoryGB: 256,
                    generation: { coreOptions: [8, 24] },
                    diskConfig: { isTiered: false, capacity: { count: 4, sizeGB: 3584, type: 'NVMe' } }
                };
                let ncStub = document.getElementById('node-count');
                const createdNc = !ncStub;
                if (createdNc) {
                    ncStub = document.createElement('select');
                    ncStub.id = 'node-count';
                    ncStub.style.display = 'none';
                    document.body.appendChild(ncStub);
                }
                const savedNodeVal = ncStub.value;
                ncStub.value = '12';
                const savedMemFlag = _memoryUserSet;
                _memoryUserSet = false;
                const maxHw = buildMaxHardwareConfig(hw);
                _memoryUserSet = savedMemFlag;
                ncStub.value = savedNodeVal;
                if (createdNc) ncStub.remove();
                return assert(maxHw.memoryGB === 1536,
                    'Large cluster (12 nodes): memory cap is 1536 GB (deterministic)', 1536, maxHw.memoryGB);
            })(),
            (() => {
                // At threshold (10 nodes), memory cap should still be 1536
                const hw = {
                    coresPerSocket: 24,
                    sockets: 2,
                    memoryGB: 256,
                    generation: { coreOptions: [8, 24] },
                    diskConfig: { isTiered: false, capacity: { count: 4, sizeGB: 3584, type: 'NVMe' } }
                };
                let ncStub = document.getElementById('node-count');
                const createdNc = !ncStub;
                if (createdNc) {
                    ncStub = document.createElement('select');
                    ncStub.id = 'node-count';
                    ncStub.style.display = 'none';
                    document.body.appendChild(ncStub);
                }
                const savedNodeVal = ncStub.value;
                ncStub.value = '10';
                const savedMemFlag = _memoryUserSet;
                _memoryUserSet = false;
                const maxHw = buildMaxHardwareConfig(hw);
                _memoryUserSet = savedMemFlag;
                ncStub.value = savedNodeVal;
                if (createdNc) ncStub.remove();
                return assert(maxHw.memoryGB === 1536,
                    'At threshold (10 nodes): memory cap is 1536 GB (deterministic)', 1536, maxHw.memoryGB);
            })(),
            (() => {
                // Below threshold (9 nodes), memory cap is also 1536 (same for all)
                const hw = {
                    coresPerSocket: 24,
                    sockets: 2,
                    memoryGB: 256,
                    generation: { coreOptions: [8, 24] },
                    diskConfig: { isTiered: false, capacity: { count: 4, sizeGB: 3584, type: 'NVMe' } }
                };
                let ncStub = document.getElementById('node-count');
                const createdNc = !ncStub;
                if (createdNc) {
                    ncStub = document.createElement('select');
                    ncStub.id = 'node-count';
                    ncStub.style.display = 'none';
                    document.body.appendChild(ncStub);
                }
                const savedNodeVal = ncStub.value;
                ncStub.value = '9';
                const savedMemFlag = _memoryUserSet;
                _memoryUserSet = false;
                const maxHw = buildMaxHardwareConfig(hw);
                _memoryUserSet = savedMemFlag;
                ncStub.value = savedNodeVal;
                if (createdNc) ncStub.remove();
                return assert(maxHw.memoryGB === 1536,
                    'Below threshold (9 nodes): memory cap is 1536 GB (deterministic)', 1536, maxHw.memoryGB);
            })()
        ]);

        // --- autoScaleHardware: conservative mode caps ---
        // Create all required DOM stubs for autoScaleHardware tests
        (() => {
            const stubConfigs = [
                { id: 'vcpu-ratio', tag: 'select', values: ['1','2','3','4','5','6','8'], defaultVal: '4' },
                { id: 'node-memory', tag: 'select', values: MEMORY_OPTIONS_GB.map(String), defaultVal: '512' },
                { id: 'cpu-manufacturer', tag: 'select', values: ['intel','amd'], defaultVal: 'intel' },
                { id: 'cpu-generation', tag: 'select', values: ['xeon-5th'], defaultVal: 'xeon-5th' },
                { id: 'cpu-cores', tag: 'select', values: ['8','16','24','32','48','64'], defaultVal: '24' },
                { id: 'cpu-sockets', tag: 'select', values: ['1','2'], defaultVal: '2' },
                { id: 'capacity-disk-count', tag: 'input', defaultVal: '4' },
                { id: 'capacity-disk-size', tag: 'select', values: DISK_SIZE_OPTIONS_TB.map(String), defaultVal: '3.84' },
                { id: 'node-count', tag: 'select', values: ['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16'], defaultVal: '3' },
                { id: 'cluster-type', tag: 'select', values: ['single','standard','rack-aware'], defaultVal: 'standard' },
                { id: 'future-growth', tag: 'select', values: ['0','10','20','30','40','50'], defaultVal: '0' },
                { id: 'resiliency', tag: 'select', values: ['simple','2way','3way','4way'], defaultVal: '2way' },
                { id: 'node-recommendation', tag: 'div', defaultVal: '' },
                { id: 'node-recommendation-text', tag: 'span', defaultVal: '' },
                { id: 'storage-config', tag: 'select', values: ['all-flash','mixed-flash','hybrid'], defaultVal: 'all-flash' }
            ];
            stubConfigs.forEach(cfg => {
                let el = document.getElementById(cfg.id);
                if (!el) {
                    el = document.createElement(cfg.tag);
                    el.id = cfg.id;
                    el.style.display = 'none';
                    if (cfg.values) {
                        cfg.values.forEach(v => {
                            const opt = document.createElement('option');
                            opt.value = v;
                            opt.text = v;
                            el.appendChild(opt);
                        });
                    }
                    document.body.appendChild(el);
                }
                if (cfg.defaultVal) el.value = cfg.defaultVal;
            });
            // Ensure node-recommendation div exists
            if (!document.getElementById('node-recommendation')) {
                const recDiv = document.createElement('div');
                recDiv.id = 'node-recommendation';
                recDiv.style.display = 'none';
                document.body.appendChild(recDiv);
            }
            if (!document.getElementById('node-recommendation-text')) {
                const recText = document.createElement('span');
                recText.id = 'node-recommendation-text';
                recText.style.display = 'none';
                document.body.appendChild(recText);
            }
        })();

        testSuite('autoScaleHardware() - conservative mode (default)', 'sizer.js', [
            (() => {
                // Conservative mode should cap memory at 2 TB even when workload needs more
                // Setup: 16 nodes, huge memory requirement that would need 3 TB per node
                const savedMemFlag = _memoryUserSet;
                const savedRatioFlag = _vcpuRatioUserSet;
                const savedCpuFlag = _cpuConfigUserSet;
                const savedDiskFlag = _diskConfigUserSet;
                _memoryUserSet = false;
                _vcpuRatioUserSet = false;
                _cpuConfigUserSet = true; // lock CPU so test focuses on memory
                _diskConfigUserSet = true; // lock disk so test focuses on memory
                document.getElementById('vcpu-ratio').value = '4';
                document.getElementById('node-memory').value = '512';
                const nodeCount = 12;
                const hwConfig = {
                    totalPhysicalCores: 128,
                    memoryGB: 512,
                    sockets: 2,
                    coresPerSocket: 64,
                    storageConfig: 'all-flash',
                    diskConfig: { isTiered: false, capacity: { count: 8, sizeGB: 3932.16, type: 'NVMe' } }
                };
                // ~30,000 GB total memory across 11 effective nodes = ~2727 GB per node needed
                autoScaleHardware(1000, 30000, 10000, nodeCount, 2, hwConfig, new Set());
                const resultMem = parseInt(document.getElementById('node-memory').value);
                const resultRatio = parseInt(document.getElementById('vcpu-ratio').value);
                // Restore
                _memoryUserSet = savedMemFlag;
                _vcpuRatioUserSet = savedRatioFlag;
                _cpuConfigUserSet = savedCpuFlag;
                _diskConfigUserSet = savedDiskFlag;
                return assert(resultMem <= 2048,
                    'Conservative mode caps memory at 2048 GB (2 TB)', '‚â§ 2048', resultMem);
            })(),
            (() => {
                // Conservative mode should NOT escalate vCPU ratio beyond 4:1
                const savedMemFlag = _memoryUserSet;
                const savedRatioFlag = _vcpuRatioUserSet;
                const savedCpuFlag = _cpuConfigUserSet;
                const savedDiskFlag = _diskConfigUserSet;
                _memoryUserSet = true; // lock memory
                _vcpuRatioUserSet = false;
                _cpuConfigUserSet = false;
                _diskConfigUserSet = true;
                document.getElementById('vcpu-ratio').value = '4';
                document.getElementById('cpu-cores').value = '64';
                document.getElementById('cpu-sockets').value = '2';
                document.getElementById('cpu-manufacturer').value = 'intel';
                document.getElementById('cpu-generation').value = 'xeon-5th';
                const nodeCount = 10;
                const hwConfig = {
                    totalPhysicalCores: 128,
                    memoryGB: 2048,
                    sockets: 2,
                    coresPerSocket: 64,
                    storageConfig: 'all-flash',
                    diskConfig: { isTiered: false, capacity: { count: 8, sizeGB: 3932.16, type: 'NVMe' } }
                };
                // Huge vCPU demand: 10000 vCPUs across 9 effective nodes at 4:1 = need 278 cores/node
                // With 128 cores, CPU at ~86%. Should NOT bump to 5:1 in conservative mode.
                autoScaleHardware(10000, 1000, 10000, nodeCount, 2, hwConfig, new Set());
                const resultRatio = parseInt(document.getElementById('vcpu-ratio').value);
                _memoryUserSet = savedMemFlag;
                _vcpuRatioUserSet = savedRatioFlag;
                _cpuConfigUserSet = savedCpuFlag;
                _diskConfigUserSet = savedDiskFlag;
                return assert(resultRatio === 4,
                    'Conservative mode keeps vCPU ratio at 4:1', 4, resultRatio);
            })()
        ]);

        testSuite('autoScaleHardware() - aggressive mode (allowRatioEscalation + allowHighMemory)', 'sizer.js', [
            (() => {
                // Aggressive mode should allow memory above 2 TB
                const savedMemFlag = _memoryUserSet;
                const savedRatioFlag = _vcpuRatioUserSet;
                const savedCpuFlag = _cpuConfigUserSet;
                const savedDiskFlag = _diskConfigUserSet;
                _memoryUserSet = false;
                _vcpuRatioUserSet = false;
                _cpuConfigUserSet = true;
                _diskConfigUserSet = true;
                document.getElementById('vcpu-ratio').value = '4';
                document.getElementById('node-memory').value = '512';
                const nodeCount = 12;
                const hwConfig = {
                    totalPhysicalCores: 128,
                    memoryGB: 512,
                    sockets: 2,
                    coresPerSocket: 64,
                    storageConfig: 'all-flash',
                    diskConfig: { isTiered: false, capacity: { count: 8, sizeGB: 3932.16, type: 'NVMe' } }
                };
                // ~30,000 GB total memory, 11 effective nodes = ~2727 GB per node needed
                autoScaleHardware(1000, 30000, 10000, nodeCount, 2, hwConfig, new Set(),
                    { allowRatioEscalation: true, allowHighMemory: true });
                const resultMem = parseInt(document.getElementById('node-memory').value);
                _memoryUserSet = savedMemFlag;
                _vcpuRatioUserSet = savedRatioFlag;
                _cpuConfigUserSet = savedCpuFlag;
                _diskConfigUserSet = savedDiskFlag;
                return assert(resultMem > 2048,
                    'Aggressive mode allows memory above 2 TB', '> 2048', resultMem);
            })(),
            (() => {
                // Aggressive mode should allow vCPU ratio escalation (4‚Üí5 or 5‚Üí6)
                const savedMemFlag = _memoryUserSet;
                const savedRatioFlag = _vcpuRatioUserSet;
                const savedCpuFlag = _cpuConfigUserSet;
                const savedDiskFlag = _diskConfigUserSet;
                _memoryUserSet = true;
                _vcpuRatioUserSet = false;
                _cpuConfigUserSet = false;
                _diskConfigUserSet = true;
                _vcpuRatioAutoEscalated = false;
                document.getElementById('vcpu-ratio').value = '4';
                document.getElementById('cpu-cores').value = '64';
                document.getElementById('cpu-sockets').value = '2';
                document.getElementById('cpu-manufacturer').value = 'intel';
                document.getElementById('cpu-generation').value = 'xeon-5th';
                const nodeCount = 10;
                const hwConfig = {
                    totalPhysicalCores: 128,
                    memoryGB: 2048,
                    sockets: 2,
                    coresPerSocket: 64,
                    storageConfig: 'all-flash',
                    diskConfig: { isTiered: false, capacity: { count: 8, sizeGB: 3932.16, type: 'NVMe' } }
                };
                // Huge vCPU demand that exceeds capacity at 4:1
                autoScaleHardware(10000, 1000, 10000, nodeCount, 2, hwConfig, new Set(),
                    { allowRatioEscalation: true, allowHighMemory: true });
                const resultRatio = parseInt(document.getElementById('vcpu-ratio').value);
                _memoryUserSet = savedMemFlag;
                _vcpuRatioUserSet = savedRatioFlag;
                _cpuConfigUserSet = savedCpuFlag;
                _diskConfigUserSet = savedDiskFlag;
                return assert(resultRatio > 4,
                    'Aggressive mode escalates vCPU ratio above 4:1', '> 4', resultRatio);
            })()
        ]);

        // --- getRecommendedNodeCount: large cluster scenarios ---
        testSuite('getRecommendedNodeCount() - large cluster scenarios', 'sizer.js', [
            (() => {
                // 1000 VMs √ó 4 vCPUs = 4000 vCPUs, √ó 16 GB = 16000 GB
                // With max hw: 128 cores √ó 4:1 = 512 vCPUs/node ‚Üí 4000/512 = 8 compute nodes + N+1 = 9
                document.getElementById('vcpu-ratio').value = '4';
                const hw = {
                    totalPhysicalCores: 128,
                    memoryGB: 2048,
                    diskConfig: { isTiered: false, capacity: { count: 24, sizeGB: 15728.64, type: 'NVMe' } }
                };
                const r = getRecommendedNodeCount(4000, 16000, 128000, hw, 2, '2way');
                return assert(r.recommended >= 9 && r.recommended <= 16,
                    '1000 VMs: recommends 9-16 nodes (compute-driven)',
                    '9-16', r.recommended);
            })(),
            (() => {
                // Memory-heavy: 500 VMs √ó 64 GB = 32000 GB memory
                // With 2 TB per node: 32000 / (2048-32) = 16 nodes needed for memory
                document.getElementById('vcpu-ratio').value = '4';
                const hw = {
                    totalPhysicalCores: 128,
                    memoryGB: 2048,
                    diskConfig: { isTiered: false, capacity: { count: 24, sizeGB: 15728.64, type: 'NVMe' } }
                };
                const r = getRecommendedNodeCount(2000, 32000, 50000, hw, 2, '2way');
                return assert(r.bottleneck === 'memory',
                    '500 VMs √ó 64 GB: memory is the bottleneck', 'memory', r.bottleneck);
            })(),
            (() => {
                // Storage-heavy: 100 VMs √ó 10 TB = 1,000,000 GB storage
                document.getElementById('vcpu-ratio').value = '4';
                const hw = {
                    totalPhysicalCores: 128,
                    memoryGB: 2048,
                    diskConfig: { isTiered: false, capacity: { count: 24, sizeGB: 15728.64, type: 'NVMe' } }
                };
                const r = getRecommendedNodeCount(400, 1600, 1000000, hw, 2, '2way');
                return assert(r.bottleneck === 'storage',
                    '100 VMs √ó 10 TB: storage is the bottleneck', 'storage', r.bottleneck);
            })(),
            (() => {
                // 2-way mirror with growth: total needs N+1 for compute/memory
                document.getElementById('vcpu-ratio').value = '4';
                const hw = {
                    totalPhysicalCores: 128,
                    memoryGB: 2048,
                    diskConfig: { isTiered: false, capacity: { count: 24, sizeGB: 15728.64, type: 'NVMe' } }
                };
                // After 10% growth: 4400 vCPUs, 17600 GB memory
                const r = getRecommendedNodeCount(4400, 17600, 140800, hw, 2, '2way');
                // compute: 4400/(128*4)=8.6 ‚Üí 9 nodes + N+1 = 10
                return assert(r.recommended >= 10,
                    'With 10% growth: recommends >= 10 nodes', '>= 10', r.recommended);
            })()
        ]);

        // --- Node preference: nodes over ratio/memory scaling ---
        testSuite('Node preference: nodes preferred over ratio escalation', 'sizer.js', [
            (() => {
                // The node recommendation with 2 TB memory cap should recommend MORE
                // nodes than with 4 TB memory cap for the same workload
                document.getElementById('vcpu-ratio').value = '4';
                const hw2tb = {
                    totalPhysicalCores: 128,
                    memoryGB: 2048,  // 2 TB cap
                    diskConfig: { isTiered: false, capacity: { count: 24, sizeGB: 15728.64, type: 'NVMe' } }
                };
                const hw4tb = {
                    totalPhysicalCores: 128,
                    memoryGB: 4096,  // 4 TB cap
                    diskConfig: { isTiered: false, capacity: { count: 24, sizeGB: 15728.64, type: 'NVMe' } }
                };
                // 20000 GB memory / (2048-32) = 10 mem nodes at 2TB vs 20000/(4096-32)=5 at 4TB
                const r2tb = getRecommendedNodeCount(2000, 20000, 50000, hw2tb, 2, '2way');
                const r4tb = getRecommendedNodeCount(2000, 20000, 50000, hw4tb, 2, '2way');
                return assert(r2tb.recommended > r4tb.recommended,
                    '2 TB cap recommends more nodes than 4 TB cap',
                    r2tb.recommended + ' > ' + r4tb.recommended,
                    r2tb.recommended + ' > ' + r4tb.recommended);
            })(),
            (() => {
                // Verify buildMaxHardwareConfig always uses 1.5 TB cap (deterministic)
                // regardless of current node count ‚Äî prevents growth from reducing nodes
                let ncStub = document.getElementById('node-count');
                const savedNodeVal = ncStub.value;
                ncStub.value = '14';
                const savedMemFlag = _memoryUserSet;
                _memoryUserSet = false;
                document.getElementById('vcpu-ratio').value = '4';
                const hw = {
                    coresPerSocket: 64,
                    sockets: 2,
                    memoryGB: 512,
                    generation: { coreOptions: [8, 16, 24, 32, 48, 64] },
                    diskConfig: { isTiered: false, capacity: { count: 8, sizeGB: 3932.16, type: 'NVMe' } }
                };
                const maxHw = buildMaxHardwareConfig(hw);
                _memoryUserSet = savedMemFlag;
                ncStub.value = savedNodeVal;
                // maxHwConfig should use 1.5 TB cap always (deterministic)
                return assert(maxHw.memoryGB === 1536,
                    'buildMaxHardwareConfig uses 1.5 TB cap for 14-node cluster (deterministic)', 1536, maxHw.memoryGB);
            })()
        ]);

        // ========================================================================
        // v0.16.01 NEW FEATURE TESTS
        // ========================================================================
        sectionHeader('üÜï v0.16.01 New Features');

        // --- DISK_SIZE_OPTIONS_TB constant ---
        testSuite('DISK_SIZE_OPTIONS_TB constant', 'sizer.js', [
            assert(Array.isArray(DISK_SIZE_OPTIONS_TB), 'Is an array', true, Array.isArray(DISK_SIZE_OPTIONS_TB)),
            assert(DISK_SIZE_OPTIONS_TB.length === 5, 'Has 5 standard sizes', 5, DISK_SIZE_OPTIONS_TB.length),
            assert(DISK_SIZE_OPTIONS_TB[0] === 0.96, 'First size: 0.96 TB', 0.96, DISK_SIZE_OPTIONS_TB[0]),
            assert(DISK_SIZE_OPTIONS_TB[1] === 1.92, 'Second size: 1.92 TB', 1.92, DISK_SIZE_OPTIONS_TB[1]),
            assert(DISK_SIZE_OPTIONS_TB[2] === 3.84, 'Third size: 3.84 TB', 3.84, DISK_SIZE_OPTIONS_TB[2]),
            assert(DISK_SIZE_OPTIONS_TB[3] === 7.68, 'Fourth size: 7.68 TB', 7.68, DISK_SIZE_OPTIONS_TB[3]),
            assert(DISK_SIZE_OPTIONS_TB[4] === 15.36, 'Fifth size: 15.36 TB', 15.36, DISK_SIZE_OPTIONS_TB[4]),
            assert(DISK_SIZE_OPTIONS_TB.every((v, i, a) => i === 0 || v > a[i - 1]), 'Sizes are in ascending order', true,
                DISK_SIZE_OPTIONS_TB.every((v, i, a) => i === 0 || v > a[i - 1]))
        ]);

        // --- tdpPerSocketW on all CPU generations ---
        testSuite('CPU_GENERATIONS: tdpPerSocketW field', 'sizer.js', [
            (() => {
                const allGens = [...CPU_GENERATIONS.intel, ...CPU_GENERATIONS.amd, ...CPU_GENERATIONS.intel_edge];
                const allHaveTdp = allGens.every(g => typeof g.tdpPerSocketW === 'number' && g.tdpPerSocketW > 0);
                return assert(allHaveTdp, 'All CPU generations have tdpPerSocketW > 0', true, allHaveTdp);
            })(),
            (() => {
                const emerald = CPU_GENERATIONS.intel.find(g => g.id === 'xeon-5th');
                return assert(emerald.tdpPerSocketW === 350, 'Emerald Rapids TDP = 350W', 350, emerald.tdpPerSocketW);
            })(),
            (() => {
                const granite = CPU_GENERATIONS.intel.find(g => g.id === 'xeon-6');
                return assert(granite.tdpPerSocketW === 500, 'Granite Rapids TDP = 500W', 500, granite.tdpPerSocketW);
            })(),
            (() => {
                const turin = CPU_GENERATIONS.amd.find(g => g.id === 'epyc-5th');
                return assert(turin.tdpPerSocketW === 500, 'AMD Turin TDP = 500W', 500, turin.tdpPerSocketW);
            })(),
            (() => {
                const genoa = CPU_GENERATIONS.amd.find(g => g.id === 'epyc-4th');
                return assert(genoa.tdpPerSocketW === 360, 'AMD Genoa TDP = 360W', 360, genoa.tdpPerSocketW);
            })(),
            (() => {
                const edge = CPU_GENERATIONS.intel_edge[0];
                return assert(edge.tdpPerSocketW === 100, 'Xeon D-2700 TDP = 100W', 100, edge.tdpPerSocketW);
            })()
        ]);

        // --- Power estimate core scaling logic ---
        testSuite('Power estimate core scaling (40% base + 60% proportional)', 'sizer.js', [
            (() => {
                // Full cores: 64/64 ‚Üí ratio=1.0, TDP = 350 √ó (0.4 + 0.6√ó1.0) = 350W
                const maxTdp = 350;
                const maxCores = 64;
                const selectedCores = 64;
                const coreRatio = selectedCores / maxCores;
                const scaledTdp = Math.round(maxTdp * (0.4 + 0.6 * coreRatio));
                return assert(scaledTdp === 350, 'Full cores (64/64): TDP = 350W', 350, scaledTdp);
            })(),
            (() => {
                // Half cores: 32/64 ‚Üí ratio=0.5, TDP = 350 √ó (0.4 + 0.6√ó0.5) = 350 √ó 0.7 = 245W
                const maxTdp = 350;
                const coreRatio = 32 / 64;
                const scaledTdp = Math.round(maxTdp * (0.4 + 0.6 * coreRatio));
                return assert(scaledTdp === 245, 'Half cores (32/64): TDP = 245W', 245, scaledTdp);
            })(),
            (() => {
                // Min cores: 8/64 ‚Üí ratio=0.125, TDP = 350 √ó (0.4 + 0.6√ó0.125) = 350 √ó 0.475 = 166W
                const maxTdp = 350;
                const coreRatio = 8 / 64;
                const scaledTdp = Math.round(maxTdp * (0.4 + 0.6 * coreRatio));
                return assert(scaledTdp === 166, 'Min cores (8/64): TDP = 166W', 166, scaledTdp);
            })(),
            (() => {
                // AMD Turin full: 192/192 ‚Üí 500W
                const maxTdp = 500;
                const coreRatio = 192 / 192;
                const scaledTdp = Math.round(maxTdp * (0.4 + 0.6 * coreRatio));
                return assert(scaledTdp === 500, 'AMD Turin full (192/192): TDP = 500W', 500, scaledTdp);
            })(),
            (() => {
                // AMD Turin 32 cores: 32/192 ‚Üí ratio=0.167, TDP = 500 √ó (0.4 + 0.6√ó0.167) = 500 √ó 0.5 = 250W
                const maxTdp = 500;
                const coreRatio = 32 / 192;
                const scaledTdp = Math.round(maxTdp * (0.4 + 0.6 * coreRatio));
                return assert(scaledTdp === 250, 'AMD Turin 32 cores (32/192): TDP = 250W', 250, scaledTdp);
            })(),
            (() => {
                // Verify scaling always >= 40% of max TDP (uncore floor)
                const maxTdp = 350;
                const coreRatio = 1 / 128; // Smallest possible ratio
                const scaledTdp = Math.round(maxTdp * (0.4 + 0.6 * coreRatio));
                return assert(scaledTdp >= maxTdp * 0.4, 'Scaled TDP never below 40% of max', '>=' + (maxTdp * 0.4), scaledTdp);
            })()
        ]);

        // --- Single node default resiliency ---
        testSuite('Single node defaults to 2-way mirror', 'sizer.js', [
            (() => {
                // Ensure stub DOM elements exist
                let ctStub = document.getElementById('cluster-type');
                if (!ctStub) {
                    ctStub = document.createElement('select');
                    ctStub.id = 'cluster-type';
                    ctStub.style.display = 'none';
                    ['single', 'standard', 'rack-aware'].forEach(v => {
                        const opt = document.createElement('option');
                        opt.value = v;
                        opt.text = v;
                        ctStub.appendChild(opt);
                    });
                    document.body.appendChild(ctStub);
                }
                let ncStub = document.getElementById('node-count');
                if (!ncStub) {
                    ncStub = document.createElement('select');
                    ncStub.id = 'node-count';
                    ncStub.style.display = 'none';
                    const opt = document.createElement('option');
                    opt.value = '1';
                    opt.text = '1';
                    ncStub.appendChild(opt);
                    document.body.appendChild(ncStub);
                }
                let resStub = document.getElementById('resiliency');
                if (!resStub) {
                    resStub = document.createElement('select');
                    resStub.id = 'resiliency';
                    resStub.style.display = 'none';
                    document.body.appendChild(resStub);
                }
                ctStub.value = 'single';
                ncStub.value = '1';
                updateResiliencyOptions();
                const selected = document.getElementById('resiliency').value;
                // Restore to standard for other tests
                ctStub.value = 'standard';
                ncStub.value = '3';
                updateResiliencyOptions();
                return assert(selected === '2way', 'Single node defaults to 2-way mirror', '2way', selected);
            })(),
            (() => {
                // Verify single node has both simple and 2way as options
                document.getElementById('cluster-type').value = 'single';
                document.getElementById('node-count').value = '1';
                updateResiliencyOptions();
                const opts = Array.from(document.getElementById('resiliency').options).map(o => o.value);
                document.getElementById('cluster-type').value = 'standard';
                document.getElementById('node-count').value = '3';
                updateResiliencyOptions();
                return assert(opts.includes('simple') && opts.includes('2way'),
                    'Single node has simple and 2way options', '["simple","2way"]', JSON.stringify(opts));
            })()
        ]);

        // --- calculateWorkloadRequirements() with custom AVD ---
        testSuite('calculateWorkloadRequirements() - AVD Custom', 'sizer.js', [
            (() => {
                const w = { type: 'avd', profile: 'custom', userCount: 50, customVcpus: 8, customMemory: 32, customStorage: 200 };
                const r = calculateWorkloadRequirements(w);
                return assert(r.vcpus === 400 && r.memory === 1600 && r.storage === 10000,
                    'AVD Custom: 50 users √ó 8/32/200 = 400/1600/10000', '400/1600/10000',
                    r.vcpus + '/' + r.memory + '/' + r.storage);
            })()
        ]);

        // ========================================================================
        // FINAL SUMMARY
        // ========================================================================
        updateTestSummary();
        
        setTimeout(() => {
            if (failCount === 0) {
                document.body.style.borderTop = '5px solid #10b981';
                console.log(`‚úì All ${totalCount} tests passed!`);
            } else {
                document.body.style.borderTop = '5px solid #ef4444';
                console.log(`‚úó ${failCount} of ${totalCount} test(s) failed`);
            }
        }, 100);
    </script>
</body>
</html>
